<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Churchill Solitaire - Churchill's Revenge</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #8B4513, #A0522D);
            font-family: 'Georgia', serif;
            color: white;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        button {
            background: rgba(0,0,0,0.7);
            color: white;
            border: 2px solid gold;
            padding: 10px 15px;
            margin: 5px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Georgia', serif;
        }
        button:hover {
            background: rgba(0,0,0,0.9);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            text-align: right;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 3px solid gold;
            border-radius: 10px;
            font-size: 24px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button id="newGame">New Game</button>
        <button id="deal">Deal</button>
        <button id="hint">Hint</button>
        <button id="undo">Undo</button>
    </div>
    <div id="status">
        <div>Time: <span id="time">00:00</span></div>
        <div>Deals: <span id="deals">0</span></div>
        <div>Rank: Sandhurst Cadet</div>
        <div>Career Score: 0</div>
    </div>
    <div id="message">
        <div id="messageText"></div>
        <button onclick="hideMessage(); newGame();">Play Again</button>
    </div>
    <canvas id="game"></canvas>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        let rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        window.addEventListener('resize', () => {
            rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            draw();
        });

        // Suits and ranks
        const suits = ['♠', '♥', '♦', '♣'];
        const suitColors = { '♠': 'black', '♥': 'red', '♦': 'red', '♣': 'black' };
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const rankValues = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.faceUp = false;
            }
            get color() { return suitColors[this.suit]; }
            get value() { return rankValues[this.rank]; }
            get name() { return this.rank + this.suit; }
        }

        // Game state
        let deck = [];
        let tableau = Array(10).fill().map(() => []);
        let devilsSix = [];
        let foundations = Array(8).fill(null); // 8 foundations for dual decks
        let stock = [];
        let selected = null;
        let dragging = null;
        let gameWon = false;
        let gameLost = false;
        let dealsLeft = 0;
        let timeStart = 0;
        let timeInterval = null;
        let hintTimeout = null;
        let undoStack = [];
        let lastDraw = 0;

        // Layout
        let CARD_W = 80;
        let CARD_H = 120;
        let OVERLAP = 20;

        function resizeLayout() {
            rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            CARD_W = Math.max(60, Math.min(90, width / 15));
            CARD_H = CARD_W * 1.5;
            OVERLAP = CARD_W * 0.25;
            const maxStackHeight = (height - 200) / OVERLAP; // Available height below UI
            if (tableau.some(col => col.length > maxStackHeight)) {
                const scale = maxStackHeight / Math.max(...tableau.map(col => col.length));
                CARD_W *= scale;
                CARD_H *= scale;
                OVERLAP *= scale;
            }
        }

        function initDeck() {
            deck = [];
            for (let i = 0; i < 2; i++) { // two decks
                suits.forEach(suit => {
                    ranks.forEach(rank => {
                        deck.push(new Card(suit, rank));
                    });
                });
            }
            shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function deal() {
            initDeck();
            tableau = Array(10).fill().map(() => []);
            devilsSix = [];
            foundations = Array(8).fill(null);
            stock = [];

            // Deal Devil's Six
            for (let i = 0; i < 6; i++) {
                devilsSix.push(deck.pop());
                devilsSix[i].faceUp = true;
            }

            // Deal tableau pyramid
            const downCounts = [0, 1, 2, 3, 4, 4, 3, 2, 1, 0];
            for (let col = 0; col < 10; col++) {
                for (let d = 0; d < downCounts[col]; d++) {
                    const card = deck.pop();
                    card.faceUp = false;
                    tableau[col].push(card);
                }
                const upCard = deck.pop();
                upCard.faceUp = true;
                tableau[col].push(upCard);
            }

            stock = deck;
            dealsLeft = stock.length / 10 | 0;
            gameWon = false;
            gameLost = false;
            if (timeInterval) clearInterval(timeInterval);
            timeStart = Date.now();
            timeInterval = setInterval(updateTime, 1000);
            updateUI();
            autoMoveAces();
            draw();
        }

        function updateTime() {
            const elapsed = Math.floor((Date.now() - timeStart) / 1000);
            const mins = (elapsed / 60 | 0).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('time').textContent = `${mins}:${secs}`;
        }

        function getXY(col, baseY = 200) {
            resizeLayout();
            const startX = 50;
            const colW = (canvas.width - 100) / 9;
            const x = startX + col * colW;
            const y = baseY;
            return {x, y};
        }

        function drawCard(card, x, y, highlight = false) {
            ctx.save();
            ctx.translate(x, y);
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;

            ctx.fillStyle = highlight ? '#FFD700' : 'white';
            ctx.fillRect(0, 0, CARD_W, CARD_H);
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'black';
            ctx.strokeRect(0, 0, CARD_W, CARD_H);

            if (card && card.faceUp) {
                ctx.fillStyle = card.color;
                ctx.font = `${CARD_W / 3}px Arial Black`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(card.rank, 8, CARD_H / 4);
                ctx.fillText(card.suit, 8, 3 * CARD_H / 4);
                ctx.save();
                ctx.translate(CARD_W - 8, CARD_H / 4);
                ctx.rotate(Math.PI / 2);
                ctx.font = `${CARD_W / 5}px Arial Black`;
                ctx.fillText(card.suit, 0, 0);
                ctx.restore();
                ctx.save();
                ctx.translate(CARD_W - 8, 3 * CARD_H / 4);
                ctx.rotate(Math.PI / 2);
                ctx.fillText(card.suit, 0, 0);
                ctx.restore();
            } else if (card) {
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(5, 5, CARD_W - 10, CARD_H - 10);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CS', CARD_W / 2, CARD_H / 2);
            }

            ctx.restore();
        }

        function draw() {
            if (Date.now() - lastDraw < 16) return; // ~60fps cap
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            resizeLayout();

            // Foundations (top-right, 8 piles in 2 rows)
            const fStartX = canvas.width - 400;
            const fY = 20;
            for (let i = 0; i < 8; i++) {
                const fx = fStartX + (i % 4) * 70 + (i > 3 ? 50 : 0);
                drawCard(foundations[i], fx, fY + (i > 3 ? 150 : 0));
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                const suitSym = suits[i % 4];
                ctx.fillText(suitSym, fx + CARD_W / 2, fY + 20 + CARD_H + (i > 3 ? 150 : 0));
            }

            // Devil's Six (top-left)
            const dsX = 20;
            const dsY = 20;
            for (let i = 0; i < 6; i++) {
                drawCard(devilsSix[i], dsX + i * 55, dsY);
            }

            // Stock (right of Devil's Six)
            const stockX = dsX + 6 * 55 + 20;
            const stockY = dsY;
            drawCard(stock.length ? {faceUp: false} : null, stockX, stockY);

            // Tableau (below)
            for (let col = 0; col < 10; col++) {
                const {x, y} = getXY(col);
                let row = 0;
                for (let j = 0; j < tableau[col].length; j++) {
                    const card = tableau[col][j];
                    const highlight = selected && selected.col === col && selected.idx <= j;
                    drawCard(card, x, y + row * OVERLAP, highlight);
                    row++;
                }
            }

            // Dragging
            if (dragging) {
                drawCard(dragging.card, mouseX - CARD_W / 2, mouseY - CARD_H / 2, true);
            }

            // Visual feedback
            if (selected) {
                const {x, y} = getXY(selected.col);
                let py = y;
                for (let i = 0; i <= selected.idx; i++) py += OVERLAP;
                ctx.strokeStyle = 'gold';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, py - OVERLAP, CARD_W, CARD_H);
            }

            lastDraw = Date.now();
        }

        let mouseX = 0, mouseY = 0;
        let mouseStartX = 0, mouseStartY = 0;
        canvas.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            mouseX = e.clientX - r.left;
            mouseY = e.clientY - r.top;
            draw();
        });

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart);
        function handleStart(e) {
            e.preventDefault();
            const r = canvas.getBoundingClientRect();
            mouseStartX = e.touches ? e.touches[0].clientX - r.left : e.clientX - r.left;
            mouseStartY = e.touches ? e.touches[0].clientY - r.top : e.clientY - r.top;
            selected = getCardAt(mouseStartX, mouseStartY);
            if (selected) {
                dragging = {card: selected.card, ox: selected.x, oy: selected.y};
            }
            draw();
        }

        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchend', handleEnd);
        function handleEnd(e) {
            e.preventDefault();
            if (dragging) {
                const target = getCardAt(mouseX, mouseY);
                if (target && tryMove(selected, target)) {
                    autoMoveAces();
                    checkWin();
                    checkLose();
                }
                dragging = null;
                selected = null;
                draw();
            }
        }

        function getCardAt(mx, my) {
            // Foundations
            const fStartX = canvas.width - 400;
            const fY = 20;
            for (let i = 0; i < 8; i++) {
                const fx = fStartX + (i % 4) * 70 + (i > 3 ? 50 : 0);
                if (mx > fx && mx < fx + CARD_W && my > fY + (i > 3 ? 150 : 0) && my < fY + CARD_H + (i > 3 ? 150 : 0) && foundations[i]) {
                    return {type: 'foundation', suitIdx: i, card: foundations[i], x: fx, y: fY + (i > 3 ? 150 : 0)};
                }
            }

            // Devil's Six
            const dsX = 20;
            const dsY = 20;
            for (let i = 0; i < 6; i++) {
                if (mx > dsX + i * 55 && mx < dsX + i * 55 + CARD_W && my > dsY && my < dsY + CARD_H) {
                    return {type: 'devils', idx: i, card: devilsSix[i], x: dsX + i * 55, y: dsY};
                }
            }

            // Stock
            const stockX = dsX + 6 * 55 + 20;
            const stockY = dsY;
            if (mx > stockX && mx < stockX + CARD_W && my > stockY && my < stockY + CARD_H && stock.length > 0) {
                doDeal();
                return null;
            }

            // Tableau
            for (let col = 0; col < 10; col++) {
                const {x, y} = getXY(col);
                let py = y;
                for (let row = tableau[col].length - 1; row >= 0; row--) {
                    if (mx > x && mx < x + CARD_W && my > py && my < py + CARD_H) {
                        return {type: 'tableau', col, idx: row, card: tableau[col][row], x, y: py};
                    }
                    py += OVERLAP;
                }
                if (tableau[col].length === 0 && mx > x && mx < x + CARD_W && my > y && my < y + CARD_H) {
                    return {type: 'tableau', col, idx: -1, card: null, x, y};
                }
            }
            return null;
        }

        function tryMove(from, to) {
            if (!from || !from.card.faceUp) return false;

            let movingCards = [from.card];
            let fromCol = null;
            if (from.type === 'tableau') {
                fromCol = from.col;
                const runLen = getBuildLength(tableau[from.col], from.idx);
                movingCards = tableau[from.col].slice(from.idx, from.idx + runLen);
                if (movingCards.length === 0) return false;
            }

            if (to.type === 'foundation') {
                const suitIdx = suits.indexOf(movingCards[0].suit) % 4 + (movingCards[0].suit.charCodeAt(0) > 127 ? 4 : 0);
                if (suitIdx !== to.suitIdx) return false;
                const top = foundations[suitIdx];
                if (!top) {
                    if (movingCards[0].value !== 1) return false; // Ace
                } else {
                    if (movingCards[0].value !== top.value + 1) return false;
                }
                undoStack.push({from: {type: from.type, col: from.col, idx: from.idx, card: from.card}, to: {type: to.type, suitIdx: to.suitIdx, card: foundations[to.suitIdx]}});
                foundations[to.suitIdx] = movingCards[0];
                if (from.type === 'tableau') {
                    tableau[from.col].splice(from.idx, movingCards.length);
                    flipTop(from.col);
                } else if (from.type === 'devils') {
                    devilsSix.splice(from.idx, 1);
                }
                return true;
            } else if (to.type === 'tableau') {
                if (from.type === 'devils') return false; // Can't move DS to tableau
                const toCol = to.col;
                const toTop = tableau[toCol][tableau[toCol].length - 1];
                if (toTop) {
                    if (movingCards[0].color === toTop.color || movingCards[0].value !== toTop.value - 1) return false;
                } else {
                    if (movingCards[0].value !== 13) return false; // King
                }
                undoStack.push({from: {type: from.type, col: from.col, idx: from.idx, card: from.card}, to: {type: to.type, col: toCol, card: tableau[toCol][tableau[toCol].length - 1]}});
                tableau[toCol].push(...movingCards);
                tableau[fromCol].splice(from.idx, movingCards.length);
                flipTop(fromCol);
                return true;
            }
            return false;
        }

        function getBuildLength(col, startIdx) {
            if (startIdx >= col.length) return 0;
            let len = 1;
            for (let i = startIdx + 1; i < col.length; i++) {
                const prev = col[i-1];
                const curr = col[i];
                if (!curr.faceUp || prev.color === curr.color || curr.value !== prev.value - 1) break;
                len++;
            }
            return len;
        }

        function flipTop(col) {
            if (tableau[col].length > 0 && !tableau[col][tableau[col].length - 1].faceUp) {
                tableau[col][tableau[col].length - 1].faceUp = true;
            }
        }

        function autoMoveAces() {
            for (let col = 0; col < 10; col++) {
                for (let i = tableau[col].length - 1; i >= 0; i--) {
                    if (tableau[col][i].faceUp && tableau[col][i].value === 1) {
                        const suitIdx = suits.indexOf(tableau[col][i].suit) % 4 + (tableau[col][i].suit.charCodeAt(0) > 127 ? 4 : 0);
                        if (!foundations[suitIdx]) {
                            foundations[suitIdx] = tableau[col][i];
                            tableau[col].splice(i, 1);
                            flipTop(col);
                        }
                    }
                }
            }
            for (let i = devilsSix.length - 1; i >= 0; i--) {
                if (devilsSix[i].value === 1) {
                    const suitIdx = suits.indexOf(devilsSix[i].suit) % 4 + (devilsSix[i].suit.charCodeAt(0) > 127 ? 4 : 0);
                    if (!foundations[suitIdx]) {
                        foundations[suitIdx] = devilsSix[i];
                        devilsSix.splice(i, 1);
                    }
                }
            }
        }

        function doDeal() {
            if (stock.length === 0 || hasMoves()) return;
            let dealt = 0;
            for (let col = 0; col < 10; col++) {
                if (tableau[col].length === 0 || tableau[col][tableau[col].length - 1].value !== 13) {
                    const card = stock.pop();
                    card.faceUp = true;
                    tableau[col].push(card);
                    dealt++;
                }
            }
            if (dealt > 0) {
                document.getElementById('deals').textContent = ++dealsLeft;
                autoMoveAces();
            }
            draw();
        }

        function hasMoves() {
            for (let col = 0; col < 10; col++) {
                if (tableau[col].some(c => c.faceUp && c.value === 1)) return true;
            }
            for (let i = 0; i < 6; i++) {
                if (devilsSix[i] && devilsSix[i].value === 1) return true;
            }
            for (let from = 0; from < 10; from++) {
                for (let to = 0; to < 10; to++) {
                    if (from === to) continue;
                    const fTop = tableau[from][tableau[from].length - 1];
                    const tTop = tableau[to][tableau[to].length - 1];
                    if (fTop && tTop && fTop.color !== tTop.color && fTop.value === tTop.value - 1) return true;
                }
            }
            return false;
        }

        function checkWin() {
            if (devilsSix.length === 0 && stock.length === 0 && tableau.every(c => c.length === 0) && foundations.every(f => f && f.value === 13)) {
                gameWon = true;
                showMessage('Victory at All Costs! You Win!');
                clearInterval(timeInterval);
                document.getElementById('newGame').disabled = false;
                document.getElementById('deal').disabled = true;
                document.getElementById('hint').disabled = true;
                document.getElementById('undo').disabled = true;
            }
        }

        function checkLose() {
            if (stock.length === 0 && !hasMoves()) {
                gameLost = true;
                showMessage('Game Over. No more moves.');
                clearInterval(timeInterval);
                document.getElementById('newGame').disabled = false;
                document.getElementById('deal').disabled = true;
                document.getElementById('hint').disabled = true;
                document.getElementById('undo').disabled = true;
            }
        }

        function showHint() {
            if (hintTimeout) clearTimeout(hintTimeout);
            let hintCard = null;
            for (let col = 0; col < 10; col++) {
                if (tableau[col].some(c => c.faceUp && c.value === 1)) hintCard = tableau[col].find(c => c.faceUp && c.value === 1);
            }
            if (!hintCard && devilsSix.some(c => c.value === 1)) hintCard = devilsSix.find(c => c.value === 1);
            if (hintCard) {
                selected = {type: 'tableau', col: 0, idx: 0, card: hintCard};
                setTimeout(() => { selected = null; draw(); }, 1000);
            }
            draw();
        }

        function showMessage(text) {
            document.getElementById('messageText').textContent = text;
            document.getElementById('message').style.display = 'block';
        }

        function hideMessage() {
            document.getElementById('message').style.display = 'none';
        }

        function updateUI() {
            document.getElementById('deal').disabled = stock.length === 0 || hasMoves();
            document.getElementById('undo').disabled = undoStack.length === 0;
        }

        // Event listeners
        document.getElementById('newGame').onclick = () => deal();
        document.getElementById('deal').onclick = doDeal;
        document.getElementById('hint').onclick = showHint;
        document.getElementById('undo').onclick = () => {
            if (undoStack.length) {
                const move = undoStack.pop();
                // Simplified revert (needs full state tracking for accuracy)
                if (move.to.type === 'foundation') {
                    foundations[move.to.suitIdx] = move.to.card;
                } else if (move.to.type === 'tableau') {
                    tableau[move.to.col].pop();
                }
                if (move.from.type === 'tableau') {
                    tableau[move.from.col].splice(move.from.idx, 0, move.from.card);
                } else if (move.from.type === 'devils') {
                    devilsSix.splice(move.from.idx, 0, move.from.card);
                }
                draw();
                updateUI();
            }
        };

        function newGame() {
            deal();
            hideMessage();
            undoStack = [];
            updateUI();
        }

        // Init
        deal();
        updateUI();
    </script>
</body>
</html>
