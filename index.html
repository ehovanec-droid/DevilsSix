<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Churchill Solitaire — Devil's Six</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }
    body {
      font-family: "Avenir Next", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #f4ede0;
      background: radial-gradient(circle at top, rgba(97, 54, 23, 0.6) 0%, rgba(26, 14, 6, 0.92) 60%),
        radial-gradient(circle at bottom, rgba(22, 12, 6, 0.92) 0%, rgba(14, 7, 3, 0.98) 62%);
      background-attachment: fixed;
      overflow-y: auto;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    #app {
      width: min(1220px, 100%);
      padding: 4px 20px 28px;
      box-sizing: border-box;
    }
    #hud {
      display: none;
    }
    #identity {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #f7e7c4;
    }
    #identity .title {
      font-size: 17px;
    }
    #identity .subtitle {
      font-size: 11px;
      color: rgba(247, 231, 196, 0.7);
      letter-spacing: 0.18em;
    }
    #ui {
      position: absolute;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 10px;
      justify-content: flex-start;
      background: linear-gradient(180deg, rgba(35, 22, 13, 0.85) 0%, rgba(22, 12, 6, 0.92) 100%);
      border-radius: 16px;
      border: 1px solid rgba(255, 222, 166, 0.32);
      padding: 16px 18px;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
      pointer-events: none;
      transform: none;
      min-width: 0;
    }
    #ui .btn {
      width: auto;
      padding: 5px 12px;
      font-size: 11px;
      letter-spacing: 0.09em;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
    }
    #stockCounter {
      position: absolute;
      pointer-events: none;
      color: #ffffff;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      white-space: nowrap;
      width: var(--stock-counter-width, auto);
    }
    .btn {
      background: linear-gradient(180deg, rgba(71, 48, 24, 0.95) 0%, rgba(38, 23, 12, 0.95) 90%);
      border: none;
      border-radius: 999px;
      color: #f9e1a7;
      padding: 10px 18px;
      font-weight: 700;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }
    .btn:focus {
      outline: none;
    }
    .btn:focus-visible {
      outline: none;
      box-shadow: 0 14px 26px rgba(0, 0, 0, 0.45);
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(0, 0, 0, 0.45);
      background: linear-gradient(180deg, rgba(92, 63, 30, 0.98) 0%, rgba(48, 29, 14, 0.98) 90%);
    }
    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    #boardArea {
      position: relative;
      background: radial-gradient(circle at center, rgba(19, 10, 4, 0.86), rgba(13, 7, 3, 0.94));
      border-radius: 24px;
      padding: 2px 22px 30px;
      box-shadow: inset 0 0 28px rgba(0, 0, 0, 0.55), 0 24px 50px rgba(0, 0, 0, 0.55);
      overflow-x: auto;
      overflow-y: auto;
      max-height: calc(100vh - 48px);
      -webkit-overflow-scrolling: touch;
    }
    #boardArea::-webkit-scrollbar {
      width: 6px;
    }
    #boardArea::-webkit-scrollbar-thumb {
      background: rgba(246, 227, 176, 0.18);
      border-radius: 999px;
    }
    #boardArea::-webkit-scrollbar-track {
      background: transparent;
    }
    #boardArea {
      scrollbar-width: thin;
      scrollbar-color: rgba(246, 227, 176, 0.18) transparent;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
      min-width: 100%;
    }
    #message {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    #messageContent {
      pointer-events: auto;
      background: rgba(17, 10, 4, 0.94);
      padding: 32px 40px;
      border: 1px solid rgba(244, 215, 140, 0.8);
      border-radius: 18px;
      box-shadow: 0 22px 36px rgba(0, 0, 0, 0.6);
      text-align: center;
      min-width: 280px;
    }
    #messageText {
      margin-bottom: 16px;
      font-size: 20px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #ffecc4;
    }
    @media (max-width: 780px) {
      #hud {
        flex-direction: column;
        gap: 12px;
        align-items: center;
      }
      #boardArea {
        padding: 6px 16px 28px;
        max-height: calc(100vh - 32px);
      }
      #ui {
        position: static;
        transform: none;
        flex-direction: row;
        justify-content: center;
        margin: 12px auto 0;
        padding: 12px 16px;
        min-width: 0;
        gap: 10px;
      }
      #ui .btn {
        width: auto;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header id="hud">
      <div id="identity">
        <div class="title">Devil's Six</div>
        <div class="subtitle" id="version"></div>
      </div>
    </header>
    <main id="boardArea">
      <div id="ui">
        <button id="newGame" class="btn">New Deal</button>
        <button id="undo" class="btn">Undo</button>
      </div>
      <div id="stockCounter"></div>
      <canvas id="game"></canvas>
      <div id="message">
        <div id="messageContent">
          <div id="messageText"></div>
          <button id="playAgain" class="btn">Play Again</button>
        </div>
      </div>
    </main>
  </div>

  <script>
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const VERSION = '2.6';
  const versionEl = document.getElementById('version');
  if (versionEl) versionEl.textContent = `Version ${VERSION}`;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const controls = document.getElementById('ui');
  const newDealButton = document.getElementById('newGame');
  const undoButton = document.getElementById('undo');
  const hintButton = document.getElementById('hint');
  const playAgainButton = document.getElementById('playAgain');
  const stockCounter = document.getElementById('stockCounter');
  const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
  const COLORS = { '\u2660':'black', '\u2663':'black', '\u2665':'red', '\u2666':'red' };
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL  = { A:1, J:11, Q:12, K:13 };
  for (let i=2;i<=10;i++) RVAL[i]=i;
  const PADDING = 16;

  class Card {
    constructor(suit, rank){
      this.suit = suit;
      this.rank = rank;
      this.value = RVAL[rank];
      this.color = COLORS[suit];
      this.faceUp = false;
    }
  }

  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]);
  let stock = [];
  let deck = [];
  let deals = 0;
  let undoStack = [];
  let isAnimatingDeal = false;

  // ★ NEW: track which tableau columns have had a king planted
  let anchoredCols = new Array(10).fill(false);

  let CARD_W = 80, CARD_H = 120;
  let FACE_UP_OVERLAP = 22;
  let FACE_DOWN_OVERLAP = 14;
  let boardWidth = 0;
  let boardHeight = 0;

  const TopGeom = {
    dsX: PADDING,
    dsY: PADDING,
    dsStep: 26,
    stockX: 0,
    stockY: 0,
    fSlots: [],
    fCols: 4,
    fRows: 2,
    fGapX: 10,
    fGapY: 8,
    fY: PADDING
  };

  function layout(w){
    const available = Math.max(260, w - PADDING * 2);
    const proposed = Math.floor(available / 12.6) + 4;
    const baseWidth = Math.max(52, Math.min(114, proposed));
    CARD_W = Math.max(44, Math.min(120, baseWidth + 4));
    CARD_H = Math.max(90, Math.floor(CARD_W * 1.45) - 4);
    FACE_UP_OVERLAP = Math.max(18, Math.floor(CARD_H * 0.24));
    FACE_DOWN_OVERLAP = Math.max(10, Math.floor(CARD_H * 0.12));
  }
  function tableauGutter(){
    const available = boardWidth - PADDING * 2 - CARD_W * 10;
    return Math.max(6, Math.floor(available / 9));
  }
  function colX(c){ return PADDING + c * (CARD_W + tableauGutter()); }
  function tableauSpacingForCard(card){
    return card && card.faceUp ? FACE_UP_OVERLAP : FACE_DOWN_OVERLAP;
  }
  function tableauRowTop(col, row){
    const colArr = tableau[col] || [];
    let y = tableauTopY();
    const limit = Math.max(0, Math.min(row, colArr.length));
    for (let i=0; i<limit; i++){
      y += tableauSpacingForCard(colArr[i]);
    }
    return y;
  }
  function tableauCardPos(col, row){
    return { x: colX(col), y: tableauRowTop(col, row) };
  }
  function devilsCardPos(idx){
    return { x: TopGeom.dsX + idx * TopGeom.dsStep, y: TopGeom.dsY };
  }
  function shouldAnchorColumn(col){
    if (!col.length) return false;
    for (let i=0;i<col.length;i++) if (!col[i].faceUp) return false;
    const base = col[0];
    return base && base.faceUp && base.value === 13;
  }
  function refreshAnchorForColumn(idx){
    anchoredCols[idx] = shouldAnchorColumn(tableau[idx]);
  }
  function refreshAllAnchors(){
    for (let i=0;i<tableau.length;i++) refreshAnchorForColumn(i);
  }
  function tableauTopY(){
    const top = TopGeom.fY + (CARD_H * TopGeom.fRows) + (TopGeom.fGapY * (TopGeom.fRows - 1)) + Math.max(2, Math.floor(CARD_H * 0.04));
    return Math.max(top, CARD_H + Math.max(12, Math.floor(CARD_H * 0.12)));
  }
  function computeTopGeometry(){
    const topBand = Math.max(3, Math.floor(CARD_H * 0.032));
    TopGeom.dsY = topBand;
    TopGeom.dsStep = Math.max(Math.floor(CARD_W * 0.32), 22);
    TopGeom.fGapX = Math.max(Math.floor(CARD_W * 0.18), 12);
    TopGeom.fGapY = Math.max(Math.floor(CARD_H * 0.055), 6);
    TopGeom.stockX = PADDING;
    TopGeom.stockY = TopGeom.dsY;
    TopGeom.fY = Math.max(4, topBand + Math.max(Math.floor(CARD_H * 0.015), 2));
    const dsSlots = Math.max(devilsSix.length, 6);
    const dsWidth = CARD_W + TopGeom.dsStep * (dsSlots - 1);
    TopGeom.dsX = TopGeom.stockX + CARD_W + Math.max(28, Math.floor(CARD_W * 0.6));

    const totalFW = TopGeom.fCols * CARD_W + (TopGeom.fCols - 1) * TopGeom.fGapX;
    const minStart = TopGeom.dsX + dsWidth + Math.max(30, Math.floor(CARD_W * 0.7));
    let startX = boardWidth - PADDING - totalFW;
    if (startX < minStart){
      startX = Math.max(PADDING, Math.min(minStart, boardWidth - PADDING - totalFW));
    }
    startX = Math.max(PADDING, startX);
    TopGeom.fSlots = [];
    for (let row=0; row<TopGeom.fRows; row++){
      for (let col=0; col<TopGeom.fCols; col++){
        const x = startX + col*(CARD_W + TopGeom.fGapX);
        const y = TopGeom.fY + row*(CARD_H + TopGeom.fGapY);
        TopGeom.fSlots.push({x,y});
      }
    }
  }
  function computeBoardHeight(){
    const baseTop = tableauTopY();
    let maxBottom = baseTop + CARD_H;
    for (let i=0;i<tableau.length;i++){
      const col = tableau[i];
      if (!col.length) continue;
      const top = tableauRowTop(i, col.length - 1);
      maxBottom = Math.max(maxBottom, top + CARD_H);
    }
    return Math.max(window.innerHeight * 0.82, maxBottom + PADDING);
  }
  function syncBoardMetrics(){
    const containerWidth = canvas.parentElement ? canvas.parentElement.clientWidth : 0;
    const width = Math.max(320, canvas.clientWidth || containerWidth || window.innerWidth);
    layout(width);

    let workingWidth = width;
    boardWidth = workingWidth;
    let gutter = Math.max(6, Math.floor((boardWidth - PADDING * 2 - CARD_W * 10) / 9));
    let required = PADDING * 2 + CARD_W * 10 + gutter * 9;

    if (required > workingWidth){
      workingWidth = required;
      boardWidth = workingWidth;
      gutter = Math.max(6, Math.floor((boardWidth - PADDING * 2 - CARD_W * 10) / 9));
      required = PADDING * 2 + CARD_W * 10 + gutter * 9;
    }

    boardWidth = Math.max(workingWidth, required);
    computeTopGeometry();

    const desiredHeight = computeBoardHeight();
    if (Math.abs(desiredHeight - boardHeight) > 1){
      boardHeight = desiredHeight;
      canvas.style.height = `${boardHeight}px`;
    }

    canvas.style.width = `${boardWidth}px`;
    canvas.width = Math.floor(boardWidth * DPR);
    canvas.height = Math.floor(boardHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  function positionControls(){
    if (!controls) return;
    if (window.innerWidth <= 780){
      controls.style.left = '';
      controls.style.top = '';
      controls.style.transform = '';
      if (stockCounter) positionStockCounter();
      return;
    }
    const dsSlots = Math.max(devilsSix.length, 6);
    const dsRightEdge = TopGeom.dsX + CARD_W + TopGeom.dsStep * (dsSlots - 1);
    const foundationLeftEdge = TopGeom.fSlots.length ? TopGeom.fSlots[0].x : dsRightEdge + CARD_W;
    const gapCenter = dsRightEdge + Math.max(0, (foundationLeftEdge - dsRightEdge) / 2);
    const controlsWidth = controls.offsetWidth || 0;
    const controlsHeight = controls.offsetHeight || 0;
    if (controlsWidth){
      controls.style.left = `${Math.round(gapCenter - controlsWidth / 2)}px`;
    } else {
      controls.style.left = `${Math.round(gapCenter)}px`;
    }
    if (controlsHeight){
      const dsCenterY = TopGeom.dsY + CARD_H / 2;
      controls.style.top = `${Math.round(dsCenterY - controlsHeight / 2)}px`;
    } else {
      const fallbackOffset = Math.max(18, Math.floor(CARD_H * 0.18));
      controls.style.top = `${Math.round(TopGeom.stockY + CARD_H + fallbackOffset)}px`;
    }
    controls.style.transform = 'none';
    if (stockCounter) positionStockCounter();
  }

  function positionStockCounter(){
    if (!stockCounter) return;
    const offsetBelow = Math.max(6, Math.floor(CARD_H * 0.08));
    const width = Math.round(CARD_W);
    stockCounter.style.setProperty('--stock-counter-width', `${width}px`);
    stockCounter.style.width = `${width}px`;
    stockCounter.style.left = `${Math.round(TopGeom.stockX)}px`;
    stockCounter.style.top = `${Math.round(TopGeom.stockY + CARD_H + offsetBelow)}px`;
  }

  function updateStockCounter(){
    if (!stockCounter) return;
    if (stock.length === 1){
      stockCounter.textContent = '1 card';
    } else {
      stockCounter.textContent = `${stock.length} cards`;
    }
    positionStockCounter();
  }
  function render(){
    syncBoardMetrics();
    draw();
  }
  function resizeCanvas(){
    render();
  }
  window.addEventListener('resize', resizeCanvas);

  let stockHit = {x:0,y:0,w:0,h:0};
  let drag = null;
  let mouseX = 0, mouseY = 0;

  function drawRoundRect(x,y,w,h,r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawCard(card,x,y,opts={}){
    const {highlight=false,empty=false,suitHint=null,ghost=false} = opts;
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = ghost ? 0.85 : 1;
    const radius = Math.max(6, CARD_W * 0.1);
    if (card){
      ctx.shadowColor = 'rgba(0,0,0,0.42)';
      ctx.shadowBlur = Math.max(12, CARD_W * 0.25);
      ctx.shadowOffsetY = Math.max(4, CARD_H * 0.08);
      const shellGradient = ctx.createLinearGradient(0,0,0,CARD_H);
      if (card.faceUp){
        shellGradient.addColorStop(0, '#faf8f4');
        shellGradient.addColorStop(0.55, '#ffffff');
        shellGradient.addColorStop(1, '#e9e3d7');
      } else {
        shellGradient.addColorStop(0, '#204a92');
        shellGradient.addColorStop(1, '#112a62');
      }
      ctx.fillStyle = shellGradient;
      drawRoundRect(0,0,CARD_W,CARD_H,radius);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      drawRoundRect(0,0,CARD_W,CARD_H,radius);
      ctx.lineWidth = card.faceUp ? 1.4 : 1.8;
      ctx.strokeStyle = card.faceUp ? '#1a1a1a' : '#0a163a';
      ctx.stroke();

      if (card.faceUp){
        const insetRadius = Math.max(5, CARD_W * 0.1);
        drawRoundRect(6,6,CARD_W-12,CARD_H-12,insetRadius);
        const faceGradient = ctx.createLinearGradient(6,6,CARD_W-6,CARD_H-6);
        faceGradient.addColorStop(0, 'rgba(255,255,255,0.92)');
        faceGradient.addColorStop(1, 'rgba(233,229,216,0.88)');
        ctx.fillStyle = faceGradient;
        ctx.fill();

        const cornerInsetX = Math.floor(CARD_W * 0.075);
        const cornerInsetY = Math.floor(CARD_H * 0.036);
        const rightInsetX = CARD_W - cornerInsetX;
        ctx.fillStyle = card.color === 'red' ? '#be1e2d' : '#141414';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.font = `700 ${Math.floor(CARD_W/3.55)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.rank, cornerInsetX, cornerInsetY);

        ctx.textAlign = 'right';
        ctx.font = `${Math.floor(CARD_W/4.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.suit, rightInsetX, cornerInsetY + Math.floor(CARD_H * 0.006));

        ctx.save();
        ctx.translate(CARD_W, CARD_H);
        ctx.rotate(Math.PI);
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.font = `700 ${Math.floor(CARD_W/3.55)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.rank, cornerInsetX, cornerInsetY);
        ctx.textAlign = 'right';
        ctx.font = `${Math.floor(CARD_W/4.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.suit, CARD_W - cornerInsetX, cornerInsetY + Math.floor(CARD_H * 0.006));
        ctx.restore();

        ctx.save();
        ctx.translate(CARD_W/2, CARD_H/2);
        ctx.font = `600 ${Math.floor(CARD_W/2.05)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.16;
        ctx.fillStyle = card.color === 'red' ? '#c23c3c' : '#262626';
        ctx.fillText(card.suit, 0, 0);
        ctx.restore();
      } else {
        const insetRadius = Math.max(5, CARD_W * 0.1);
        drawRoundRect(6,6,CARD_W-12,CARD_H-12,insetRadius);
        ctx.save();
        ctx.clip();
        const primary = ctx.createLinearGradient(0,0,CARD_W,CARD_H);
        primary.addColorStop(0, '#1b3e82');
        primary.addColorStop(1, '#102a5a');
        ctx.fillStyle = primary;
        ctx.fillRect(0,0,CARD_W,CARD_H);

        const sheen = ctx.createRadialGradient(CARD_W*0.3, CARD_H*0.25, CARD_W*0.1, CARD_W*0.3, CARD_H*0.25, CARD_W);
        sheen.addColorStop(0, 'rgba(255,255,255,0.28)');
        sheen.addColorStop(0.45, 'rgba(255,255,255,0.12)');
        sheen.addColorStop(1, 'rgba(16,42,90,0.05)');
        ctx.fillStyle = sheen;
        ctx.fillRect(0,0,CARD_W,CARD_H);

        const emblem = ctx.createRadialGradient(CARD_W/2, CARD_H/2, CARD_W*0.1, CARD_W/2, CARD_H/2, CARD_W*0.52);
        emblem.addColorStop(0, 'rgba(8,18,48,0.45)');
        emblem.addColorStop(1, 'rgba(8,18,48,0)');
        ctx.fillStyle = emblem;
        ctx.fillRect(0,0,CARD_W,CARD_H);
        ctx.restore();
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = 'rgba(255,255,255,0.32)';
        ctx.stroke();
      }

      if (highlight){
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffd86b';
        drawRoundRect(1.5,1.5,CARD_W-3,CARD_H-3, Math.max(6, radius-2));
        ctx.stroke();
      }
    } else {
      ctx.setLineDash([7,7]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(237, 202, 120, 0.8)';
      drawRoundRect(0.5,0.5,CARD_W-1,CARD_H-1,radius);
      ctx.stroke();
      ctx.setLineDash([]);
      if (suitHint){
        ctx.fillStyle = 'rgba(255,255,255,0.22)';
        ctx.font = `700 ${Math.floor(CARD_W/3.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('A'+suitHint, CARD_W/2, CARD_H/2);
      }
    }
    ctx.restore();
  }

  function draw(){
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    const dsSlots = Math.max(devilsSix.length, 6);
    for (let i=0;i<dsSlots;i++){
      const isDraggingDevil = drag && drag.from.type === 'devils' && drag.from.idx === i;
      const card = (!isDraggingDevil && devilsSix[i]) ? devilsSix[i] : null;
      if (card){
        drawCard(card, TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY);
      }
    }
    drawCard(stock.length ? {faceUp:false} : null, TopGeom.stockX, TopGeom.stockY);
    stockHit = {x:TopGeom.stockX, y:TopGeom.stockY, w:CARD_W, h:CARD_H};

    for (let i=0;i<8;i++){
      const slot = TopGeom.fSlots[i];
      const stack = foundations[i];
      const top = stack.length ? stack[stack.length-1] : null;
      drawCard(top, slot.x, slot.y, {empty:!top, suitHint:SUITS[i%4]});
    }

    const baseTY = tableauTopY();
    for (let c=0;c<10;c++){
      const x = colX(c);
      const col = tableau[c];
      if (!col.length){
        drawCard(null,x,baseTY);
        continue;
      }
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
        drawCard(card, x, tableauRowTop(c, i));
      }
    }

    if (drag){
      let baseX = (drag.renderX !== undefined ? drag.renderX : mouseX - CARD_W/2);
      let baseY = (drag.renderY !== undefined ? drag.renderY : mouseY - CARD_H/2);
      if (drag.snap){
        const strength = drag.snap.strength ?? 0.7;
        baseX = baseX * (1 - strength) + drag.snap.x * strength;
        baseY = baseY * (1 - strength) + drag.snap.y * strength;
      }
      for (let i=0;i<drag.cards.length;i++){
        drawCard(drag.cards[i], baseX, baseY + i*FACE_UP_OVERLAP, {ghost:true,highlight:true});
      }
    }
    positionControls();
  }

  let drawPending = false;
  function queueDraw(immediate=false){
    if (immediate){
      drawPending = false;
      draw();
      return;
    }
    if (drawPending) return;
    drawPending = true;
    requestAnimationFrame(()=>{
      drawPending = false;
      draw();
    });
  }

  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

  function hitAt(x,y,loose=false){
    if (!loose){
      for (let i=0;i<8;i++){
        const s = TopGeom.fSlots[i];
        if (s && x>s.x && x<s.x+CARD_W && y>s.y && y<s.y+CARD_H)
          return {type:'foundation', idx:i};
      }
      for (let i=0;i<devilsSix.length;i++){
        const dx = TopGeom.dsX + i*TopGeom.dsStep, dy=TopGeom.dsY;
        if (x>dx && x<dx+CARD_W && y>dy && y<dy+CARD_H)
          return {type:'devils', idx:i};
      }
      if (stock.length && x>stockHit.x && x<stockHit.x+CARD_W && y>stockHit.y && y<stockHit.y+CARD_H)
        return {type:'stock'};

      const tY = tableauTopY();
      for (let c=0;c<10;c++){
        const cx = colX(c);
        const col = tableau[c];
        if (!col.length){
          if (x>cx && x<cx+CARD_W && y>tY && y<tY+CARD_H) return {type:'tableau', col:c, row:-1};
          continue;
        }
        for (let i=col.length-1;i>=0;i--){
          const cy = tableauRowTop(c, i);
          if (x>cx && x<cx+CARD_W && y>cy && y<cy+CARD_H)
            return {type:'tableau', col:c, row:i};
        }
      }
      return null;
    }

    const candidates = [];
    const pushCandidate = (hit, left, top, right, bottom, priority=0)=>{
      if (x < left || x > right || y < top || y > bottom) return;
      const centerX = (left + right) / 2;
      const centerY = (top + bottom) / 2;
      const halfW = Math.max(1, (right - left) / 2);
      const halfH = Math.max(1, (bottom - top) / 2);
      const normX = (x - centerX) / halfW;
      const normY = (y - centerY) / halfH;
      const score = normX * normX + normY * normY + priority;
      candidates.push({score, hit});
    };

    const tY = tableauTopY();
    const gutter = tableauGutter();
    const baseFX = Math.max(30, Math.floor(CARD_W * 0.95));
    const baseFY = Math.max(28, Math.floor(CARD_H * 0.92));

    for (let i=0;i<TopGeom.fSlots.length;i++){
      const s = TopGeom.fSlots[i];
      if (!s) continue;
      let left = s.x - baseFX;
      let right = s.x + CARD_W + baseFX;
      let top = s.y - baseFY;
      let bottom = s.y + CARD_H + baseFY;

      if (TopGeom.fCols){
        if (i % TopGeom.fCols !== 0){
          const prev = TopGeom.fSlots[i-1];
          if (prev){
            const gap = s.x - (prev.x + CARD_W);
            const limit = Math.max(0, Math.floor(gap / 2));
            left = Math.max(left, s.x - limit);
          }
        }
        if (i % TopGeom.fCols !== TopGeom.fCols - 1){
          const next = TopGeom.fSlots[i+1];
          if (next){
            const gap = next.x - (s.x + CARD_W);
            const limit = Math.max(0, Math.floor(gap / 2));
            right = Math.min(right, s.x + CARD_W + limit);
          }
        }
      }
      const aboveIdx = i - TopGeom.fCols;
      if (aboveIdx >= 0){
        const above = TopGeom.fSlots[aboveIdx];
        if (above){
          const gap = s.y - (above.y + CARD_H);
          const limit = Math.max(0, Math.floor(gap / 2));
          top = Math.max(top, s.y - limit);
        }
      }
      const belowIdx = i + TopGeom.fCols;
      if (belowIdx < TopGeom.fSlots.length){
        const below = TopGeom.fSlots[belowIdx];
        if (below){
          const gap = below.y - (s.y + CARD_H);
          const limit = Math.max(0, Math.floor(gap / 2));
          bottom = Math.min(bottom, s.y + CARD_H + limit);
        }
      }

      pushCandidate({type:'foundation', idx:i}, left, top, right, bottom, 0);
    }

    const baseTX = Math.max(32, Math.floor(CARD_W * 1.08));
    const baseTY = Math.max(34, Math.floor(CARD_H * 0.74));
    const horizLimit = Math.max(6, Math.floor(gutter * 0.75));

    for (let c=0;c<10;c++){
      const cx = colX(c);
      const col = tableau[c];
      let leftExpand = Math.min(baseTX, horizLimit);
      let rightExpand = Math.min(baseTX, horizLimit);
      if (c === 0) leftExpand = baseTX;
      if (c === tableau.length - 1) rightExpand = baseTX;
      const left = cx - leftExpand;
      const right = cx + CARD_W + rightExpand;
      if (!col.length){
        pushCandidate({type:'tableau', col:c, row:-1}, left, tY - baseTY, right, tY + CARD_H + baseTY, 0.25);
        continue;
      }
      for (let i=col.length-1;i>=0;i--){
        const cy = tableauRowTop(c, i);
        pushCandidate({type:'tableau', col:c, row:i}, left, cy - baseTY, right, cy + CARD_H + baseTY, 0.25 + (col.length - 1 - i) * 0.001);
      }
    }

    if (!candidates.length) return null;
    candidates.sort((a,b)=>a.score - b.score);
    return candidates[0].hit;
  }

  function getRunLength(col, start){
    const arr = tableau[col];
    let len = 1;
    for (let i=start+1;i<arr.length;i++){
      const prev = arr[i-1], cur = arr[i];
      if (!cur.faceUp) break;
      if (prev.color === cur.color) break;
      if (cur.value !== prev.value - 1) break;
      len++;
    }
    return len;
  }
  function canPlaceOnTableau(card, toCol){
    const col = tableau[toCol];
    const top = col[col.length-1];
    if (!top) return card.value === 13;
    return (card.color !== top.color) && (card.value === top.value - 1);
  }
  function canPlaceOnFoundation(card, fIdx){
    if (SUITS[fIdx % 4] !== card.suit) return false;
    const stack = foundations[fIdx];
    const top   = stack[stack.length-1];
    return top ? (card.value === top.value + 1) : (card.value === 1);
  }
  function flipTop(col){
    const colArr = tableau[col];
    if (colArr.length && !colArr[colArr.length-1].faceUp)
      colArr[colArr.length-1].faceUp = true;
    refreshAnchorForColumn(col);
  }
  function canStartDragAt(col, row){
    const colArr = tableau[col];
    if (row < 0 || row >= colArr.length) return false;
    const card = colArr[row];
    if (!card.faceUp) return false;
    return true;
  }

  // ===== DEAL =====
  async function doDeal(){
    if (isAnimatingDeal) return;
    if (!stock.length) {
      render();
      updateUI();
      return;
    }

    refreshAllAnchors();

    // if ALL columns are anchored-by-king, don't deal
    let allAnchored = true;
    for (let c=0;c<10;c++){
      if (!anchoredCols[c]) {
        allAnchored = false;
        break;
      }
    }
    if (allAnchored) {
      render();
      updateUI();
      return;
    }

    const dealt = [];
    for (let c=0;c<10;c++){
      if (!stock.length) break;
      if (anchoredCols[c]) continue;

      const card = stock.pop();
      if (!card) break;
      card.faceUp = true;
      dealt.push({col:c, card});
    }

    if (!dealt.length){
      render();
      updateUI();
      return;
    }

    deals++;
    undoStack.push({kind:'deal', payload:dealt.map(step=>({col:step.col, card:step.card}))});
    isAnimatingDeal = true;
    if (newDealButton) newDealButton.disabled = true;
    updateUI(true);

    const stepDelay = Math.max(45, Math.min(140, Math.floor(1200 / Math.max(1, dealt.length))));
    try {
      for (let i=0;i<dealt.length;i++){
        const step = dealt[i];
        tableau[step.col].push(step.card);
        refreshAnchorForColumn(step.col);
        render();
        if (i < dealt.length - 1) await sleep(stepDelay);
      }
    } finally {
      isAnimatingDeal = false;
      if (newDealButton) newDealButton.disabled = false;
    }

    render();
    updateUI();
    checkWinOrStuck();
  }

  function hasAnyMoves(){
    for (let c=0;c<10;c++){
      const top = tableau[c][tableau[c].length-1];
      if (!top) continue;
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(top,f)) return true;
    }
    for (const card of devilsSix){
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(card,f)) return true;
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      const start = col.findIndex(c=>c.faceUp);
      if (start<0) continue;
      for (let i=start;i<col.length;i++){
        const base = col[i];
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(base,to)) return true;
        }
      }
    }
    return false;
  }
  function checkWinOrStuck(){
    const total = foundations.reduce((n,s)=>n+s.length,0);
    if (total === 104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      finishGame(true);
      return;
    }
    if (!stock.length && !hasAnyMoves()){
      finishGame(false);
    }
  }
  function finishGame(win){
    if (win){
      showMessage('Victory! Foundations complete.');
    } else {
      showMessage('No more moves.');
    }
  }

  function buildDeck(){
    const temp = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          temp.push(new Card(s,r));
        }
      }
    }
    for (let i=temp.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [temp[i], temp[j]] = [temp[j], temp[i]];
    }
    deck = temp;
  }
  function drawDevilsSixFromDeck(){
    const cards = [];
    for (let i=0;i<6;i++){
      const c = deck.pop();
      c.faceUp = true;
      cards.push(c);
    }
    return cards;
  }

  function isDevilsSixUnwinnable(cards){
    const suitOrder = {};
    for (let i=cards.length-1;i>=0;i--){
      const card = cards[i];
      if (!suitOrder[card.suit]) suitOrder[card.suit] = [];
      suitOrder[card.suit].push(card.value);
    }
    for (const ordered of Object.values(suitOrder)){
      let streak = 1;
      for (let i=0;i<ordered.length-1;i++){
        if (ordered[i] === ordered[i+1] + 1){
          streak++;
          if (streak >= 2) return true;
        } else {
          streak = 1;
        }
      }
    }
    return false;
  }

  function repairDevilsSix(cards){
    for (let i=0;i<cards.length;i++){
      const original = cards[i];
      const originalFace = original.faceUp;
      for (let j=0;j<deck.length;j++){
        const replacement = deck[j];
        const replacementFace = replacement.faceUp;
        cards[i] = replacement;
        replacement.faceUp = true;
        original.faceUp = false;
        if (!isDevilsSixUnwinnable(cards)){
          deck[j] = original;
          return cards;
        }
        cards[i] = original;
        original.faceUp = originalFace;
        replacement.faceUp = replacementFace;
      }
      cards[i] = original;
      original.faceUp = originalFace;
    }
    return null;
  }

  function preparePlayableDevilsSix(){
    const MAX_ATTEMPTS = 5000;
    let attempt = 0;
    let candidate = [];
    while (attempt < MAX_ATTEMPTS){
      buildDeck();
      candidate = drawDevilsSixFromDeck();
      if (!isDevilsSixUnwinnable(candidate)){
        return candidate;
      }
      attempt++;
    }

    const repaired = repairDevilsSix(candidate);
    if (repaired){
      console.warn('Devil\'s Six required repair after repeated unwinnable draws.');
      return repaired;
    }
    console.warn('Unable to find a guaranteed winnable Devil\'s Six after many attempts; proceeding with current deal.');
    return candidate;
  }

  function newGame(){
    undoStack = [];
    anchoredCols = new Array(10).fill(false);
    foundations = new Array(8).fill(0).map(()=>[]);
    tableau = new Array(10).fill(0).map(()=>[]);
    stock = [];

    const freshDevilsSix = preparePlayableDevilsSix();
    devilsSix = freshDevilsSix;

    const downs = [0,1,2,3,4,4,3,2,1,0];
    for (let col=0; col<10; col++){
      for (let d=0; d<downs[col]; d++){
        const c = deck.pop();
        c.faceUp = false;
        tableau[col].push(c);
      }
      const up = deck.pop();
      up.faceUp = true;
      tableau[col].push(up);
    }

    stock = deck;
    deals = 0;

    refreshAllAnchors();
    updateUI();
    render();
  }

  function updateUI(disable=false){
    updateStockCounter();
    if (undoButton) undoButton.disabled = disable || undoStack.length===0;
    if (hintButton) hintButton.disabled = disable;
  }
  function showMessage(t){
    document.getElementById('messageText').textContent = t;
    document.getElementById('message').style.display = 'flex';
    updateUI(true);
  }
  function hideMessage(){ document.getElementById('message').style.display = 'none'; }

  function getCanvasPos(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  function computeDragSnap(x, y){
    if (!drag) return null;
    const drop = hitAt(x, y, true);
    if (!drop) return null;
    const moving = drag.cards[0];

    if (drop.type === 'foundation'){
      if (drag.cards.length !== 1) return null;
      if (!canPlaceOnFoundation(moving, drop.idx)) return null;
      const slot = TopGeom.fSlots[drop.idx];
      if (!slot) return null;
      return { x: slot.x, y: slot.y, strength: 0.92 };
    }

    if (drop.type === 'tableau'){
      if (!canPlaceOnTableau(moving, drop.col)) return null;
      if (drag.from.type === 'tableau' && drop.col === drag.from.col && drop.row >= drag.from.idx) return null;
      let depth;
      if (drop.row >= 0){
        depth = drop.row + 1;
      } else {
        depth = tableau[drop.col].length;
      }
      if (drag.from.type === 'tableau' && drop.col === drag.from.col && depth > drag.from.idx){
        depth = Math.max(drag.from.idx, depth - drag.cards.length);
      }
      const snapY = tableauRowTop(drop.col, depth);
      return { x: colX(drop.col), y: snapY, strength: 0.88 };
    }

    return null;
  }

  function handlePrimaryMove(x, y){
    mouseX = x;
    mouseY = y;
    if (drag){
      drag.renderX = x - drag.offsetX;
      drag.renderY = y - drag.offsetY;
      drag.snap = computeDragSnap(x, y);
      queueDraw();
    }
  }

  function handlePrimaryDown(x, y){
    mouseX = x;
    mouseY = y;
    if (isAnimatingDeal) return false;
    const hit = hitAt(x, y);
    if (!hit) return false;

    if (hit.type === 'stock'){
      doDeal();
      return true;
    }

    if (hit.type === 'tableau' && hit.row >= 0){
      const card = tableau[hit.col][hit.row];
      if (card && card.faceUp && card.value === 1){
        const candidates = [];
        for (let f=0;f<8;f++) if (SUITS[f%4] === card.suit) candidates.push(f);
        let placed = false;
        for (const f of candidates){
          if (foundations[f].length === 0){
            foundations[f].push(card);
            tableau[hit.col].splice(hit.row,1);
            flipTop(hit.col);
            undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card});
            placed = true;
            break;
          }
        }
        if (!placed){
          for (const f of candidates){
            if (canPlaceOnFoundation(card, f)){
              foundations[f].push(card);
              tableau[hit.col].splice(hit.row,1);
              flipTop(hit.col);
              undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card});
              placed = true;
              break;
            }
          }
        }
        if (placed){
          render();
          updateUI();
          checkWinOrStuck();
          return true;
        }
      }
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      if (card && card.value === 1){
        const candidates = [];
        for (let f=0;f<8;f++) if (SUITS[f%4] === card.suit) candidates.push(f);
        let placed = false;
        for (const f of candidates){
          if (foundations[f].length === 0){
            foundations[f].push(card);
            devilsSix.splice(hit.idx,1);
            undoStack.push({kind:'toFound', from:{type:'devils',idx:hit.idx}, fIdx:f, card});
            placed = true;
            break;
          }
        }
        if (!placed){
          for (const f of candidates){
            if (canPlaceOnFoundation(card, f)){
              foundations[f].push(card);
              devilsSix.splice(hit.idx,1);
              undoStack.push({kind:'toFound', from:{type:'devils',idx:hit.idx}, fIdx:f, card});
              placed = true;
              break;
            }
          }
        }
        if (placed){
          render();
          updateUI();
          checkWinOrStuck();
          return true;
        }
      }
    }

    if (hit.type === 'tableau'){
      if (hit.row < 0) return false;
      if (!canStartDragAt(hit.col, hit.row)) return false;
      const runLen = getRunLength(hit.col, hit.row);
      const origin = tableauCardPos(hit.col, hit.row);
      const offsetX = Math.max(0, Math.min(CARD_W, x - origin.x));
      const offsetY = Math.max(0, Math.min(CARD_H, y - origin.y));
      drag = {
        from: {type:'tableau', col:hit.col, idx:hit.row},
        cards: tableau[hit.col].slice(hit.row, hit.row + runLen),
        offsetX,
        offsetY,
        renderX: origin.x,
        renderY: origin.y,
        snap: null
      };
      drag.snap = computeDragSnap(x, y);
      queueDraw();
      return true;
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      const origin = devilsCardPos(hit.idx);
      const offsetX = Math.max(0, Math.min(CARD_W, x - origin.x));
      const offsetY = Math.max(0, Math.min(CARD_H, y - origin.y));
      drag = {
        from:{type:'devils', idx:hit.idx},
        cards:[card],
        offsetX,
        offsetY,
        renderX: origin.x,
        renderY: origin.y,
        snap: null
      };
      drag.snap = computeDragSnap(x, y);
      queueDraw();
      return true;
    }

    return false;
  }

  function handlePrimaryUp(x, y){
    if (!drag){
      mouseX = x;
      mouseY = y;
      return;
    }
    mouseX = x;
    mouseY = y;
    const drop = hitAt(mouseX, mouseY, true);
    const moving = drag.cards[0];
    let moved = false;

    if (drop){
      // to foundation
      if (drop.type === 'foundation' && drag.cards.length === 1 && canPlaceOnFoundation(moving, drop.idx)){
        foundations[drop.idx].push(moving);
        if (drag.from.type === 'tableau'){
          tableau[drag.from.col].splice(drag.from.idx,1);
          flipTop(drag.from.col);
        } else {
          devilsSix.splice(drag.from.idx,1);
        }
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        moved = true;
      }
      // tableau-to-tableau
      else if (drop.type === 'tableau' && drag.from.type === 'tableau' && canPlaceOnTableau(moving, drop.col)){
        const run = drag.cards.slice();
        const toCol = drop.col;
        const fromCol = drag.from.col;
        tableau[toCol].push(...run);
        tableau[fromCol].splice(drag.from.idx, run.length);
        refreshAnchorForColumn(toCol);
        flipTop(fromCol);

        undoStack.push({
          kind:'tab2tab',
          from:{col:fromCol, idx:drag.from.idx},
          toCol:toCol,
          count:run.length
        });
        moved = true;
      }
      else if (drop.type === 'tableau' && drag.from.type === 'devils' && canPlaceOnTableau(moving, drop.col)){
        const toCol = drop.col;
        tableau[toCol].push(moving);
        devilsSix.splice(drag.from.idx,1);
        refreshAnchorForColumn(toCol);
        undoStack.push({
          kind:'devils2tab',
          toCol,
          fromIdx: drag.from.idx
        });
        moved = true;
      }
    }

    drag = null;
    render();
    if (moved){
      updateUI();
      checkWinOrStuck();
    }
  }

  function cancelDrag(){
    if (drag){
      drag = null;
      render();
    }
  }

  canvas.addEventListener('contextmenu', e=> e.preventDefault());

  const supportsPointer = 'PointerEvent' in window;
  if (supportsPointer){
    let activePointerId = null;
    const isPrimaryPointer = e => {
      if (e.pointerType === 'mouse') return e.button === 0;
      return true;
    };
    canvas.addEventListener('pointerdown', e=>{
      if (activePointerId !== null) return;
      if (!isPrimaryPointer(e)) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      const startedDrag = !!drag;
      if (startedDrag){
        try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
        activePointerId = e.pointerId;
      }
      if (handled && e.pointerType !== 'mouse') e.preventDefault();
    }, {passive:false});
    canvas.addEventListener('pointermove', e=>{
      if (activePointerId !== e.pointerId) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryMove(pos.x, pos.y);
      if (drag && e.pointerType !== 'mouse') e.preventDefault();
    }, {passive:false});
    const finishPointer = e=>{
      if (activePointerId !== e.pointerId) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryUp(pos.x, pos.y);
      activePointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      if (e.pointerType !== 'mouse') e.preventDefault();
    };
    canvas.addEventListener('pointerup', finishPointer, {passive:false});
    window.addEventListener('pointerup', finishPointer, {passive:false});
    const cancelPointer = e=>{
      if (activePointerId !== e.pointerId) return;
      activePointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      cancelDrag();
      if (e.pointerType !== 'mouse') e.preventDefault();
    };
    canvas.addEventListener('pointercancel', cancelPointer, {passive:false});
    window.addEventListener('pointercancel', cancelPointer, {passive:false});
    canvas.addEventListener('lostpointercapture', e=>{
      if (activePointerId !== e.pointerId) return;
      activePointerId = null;
      cancelDrag();
    });
  } else {
    canvas.addEventListener('mousemove', e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryMove(pos.x, pos.y);
    });
    canvas.addEventListener('mousedown', e=>{
      if (e.button !== 0) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      if (handled) e.preventDefault();
    });
    window.addEventListener('mouseup', e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryUp(pos.x, pos.y);
    });

    let activeTouchId = null;
    canvas.addEventListener('touchstart', e=>{
      if (activeTouchId !== null) return;
      const touch = e.changedTouches[0];
      if (!touch) return;
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      const startedDrag = !!drag;
      if (!handled) return;
      if (startedDrag) {
        activeTouchId = touch.identifier;
      }
      e.preventDefault();
    }, {passive:false});
    window.addEventListener('touchmove', e=>{
      if (activeTouchId === null) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (touch.identifier === activeTouchId){
          const pos = getCanvasPos(touch.clientX, touch.clientY);
          handlePrimaryMove(pos.x, pos.y);
          if (drag) e.preventDefault();
          break;
        }
      }
    }, {passive:false});
    const finishTouch = e=>{
      if (activeTouchId === null) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (touch.identifier === activeTouchId){
          const pos = getCanvasPos(touch.clientX, touch.clientY);
          handlePrimaryUp(pos.x, pos.y);
          activeTouchId = null;
          e.preventDefault();
          break;
        }
      }
    };
    window.addEventListener('touchend', finishTouch, {passive:false});
    window.addEventListener('touchcancel', e=>{
      if (activeTouchId === null) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (touch.identifier === activeTouchId){
          activeTouchId = null;
          cancelDrag();
          break;
        }
      }
    });
  }

  if (undoButton) undoButton.addEventListener('click', ()=>{
    if (isAnimatingDeal) return;
    if (!undoStack.length) return;
    const step = undoStack.pop();
    if (step.kind === 'deal'){
      const touched = new Set();
      for (let i=step.payload.length-1;i>=0;i--){
        const {col,card} = step.payload[i];
        tableau[col].pop();
        card.faceUp = false;
        stock.push(card);
        touched.add(col);
      }
      deals = Math.max(0, deals-1);
      touched.forEach(refreshAnchorForColumn);
    } else if (step.kind === 'tab2tab'){
      const moved = tableau[step.toCol].splice(-step.count, step.count);
      tableau[step.from.col].splice(step.from.idx, 0, ...moved);
      refreshAnchorForColumn(step.toCol);
      flipTop(step.from.col);
    } else if (step.kind === 'devils2tab'){
      const card = tableau[step.toCol].pop();
      if (card){
        devilsSix.splice(step.fromIdx,0,card);
      }
      refreshAnchorForColumn(step.toCol);
    } else if (step.kind === 'toFound'){
      const card = foundations[step.fIdx].pop();
      if (step.from.type === 'tableau'){
        tableau[step.from.col].splice(step.from.idx,0,card);
        refreshAnchorForColumn(step.from.col);
      } else {
        devilsSix.splice(step.from.idx,0,card);
      }
    }
    render();
    updateUI();
  });

  function hint(){
    if (isAnimatingDeal) return;
    for (let c=0;c<10;c++){
      const col = tableau[c];
      const top = col[col.length-1];
      if (!top) continue;
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(top,f)){
          const topY = tableauRowTop(c, col.length - 1);
          flash(()=>{ drawCard(top, colX(c), topY, {highlight:true}); });
          return;
        }
      }
    }
    for (let i=0;i<devilsSix.length;i++){
      const card = devilsSix[i];
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(card,f)){
          flash(()=>{ drawCard(card, TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY, {highlight:true}); });
          return;
        }
      }
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (!card.faceUp) continue;
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(card,to)){
            const hintY = tableauRowTop(from, i);
            flash(()=>{ drawCard(card, colX(from), hintY, {highlight:true}); });
            return;
          }
        }
      }
    }
  }
  function flash(paint){
    let n=0;
    const id=setInterval(()=>{
      render();
      if (n%2===0) paint();
      if (++n>5) clearInterval(id);
    },120);
  }

  if (newDealButton) newDealButton.addEventListener('click', ()=>{
    if (isAnimatingDeal) return;
    hideMessage();
    newGame();
  });
  if (hintButton) hintButton.addEventListener('click', hint);
  if (playAgainButton) playAgainButton.addEventListener('click', ()=>{ hideMessage(); newGame(); });

  function runTests(){
    const results = [];
    results.push(['8 foundations', Array.isArray(foundations) && foundations.length === 8]);
    results.push(['10 tableau columns', Array.isArray(tableau) && tableau.length === 10]);
    results.push(['Devil’s Six is 6 cards', Array.isArray(devilsSix) && devilsSix.length === 6]);
    results.push(['Devil’s Six faceup', devilsSix.every(c => c && c.faceUp)]);
    const failed = results.filter(r=>!r[1]);
    const el = document.getElementById('testout');
    if (el){
      el.textContent = failed.length
        ? `Tests: ${results.length - failed.length}/${results.length} passed, ${failed.length} failed`
        : `Tests: ${results.length} passed`;
    }
  }

  resizeCanvas();
  newGame();
  runTests();
  </script>
</body>
</html>
