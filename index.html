<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Churchill Solitaire — Devil's Six</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }
    body {
      font-family: "Avenir Next", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #f4ede0;
      background: radial-gradient(circle at top, rgba(97, 54, 23, 0.6) 0%, rgba(26, 14, 6, 0.9) 58%),
        repeating-linear-gradient(135deg, #3d2210 0px, #3d2210 8px, #2a1709 8px, #2a1709 16px);
      background-attachment: fixed;
      overflow-y: auto;
      user-select: none;
      display: flex;
      justify-content: center;
    }
    #app {
      width: min(1220px, 100%);
      padding: 32px 32px 64px;
      box-sizing: border-box;
    }
    #hud {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 18px 24px;
      background: linear-gradient(180deg, rgba(35, 22, 13, 0.82) 0%, rgba(22, 12, 6, 0.88) 100%);
      border: 1px solid rgba(255, 222, 166, 0.28);
      border-radius: 18px;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
      margin-bottom: 28px;
      backdrop-filter: blur(2px);
    }
    #identity {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #f7e7c4;
    }
    #identity .subtitle {
      font-size: 12px;
      color: rgba(247, 231, 196, 0.75);
      letter-spacing: 0.16em;
    }
    #ui {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .btn {
      background: linear-gradient(180deg, rgba(71, 48, 24, 0.95) 0%, rgba(38, 23, 12, 0.95) 90%);
      border: 1px solid rgba(249, 212, 102, 0.8);
      border-radius: 999px;
      color: #f9e1a7;
      padding: 10px 18px;
      font-weight: 700;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(0, 0, 0, 0.45);
      background: linear-gradient(180deg, rgba(92, 63, 30, 0.98) 0%, rgba(48, 29, 14, 0.98) 90%);
    }
    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    #status {
      display: flex;
      gap: 18px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 13px;
      color: #f4e3bd;
    }
    #status span {
      display: inline-block;
      min-width: 48px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #fff5d1;
    }
    #boardArea {
      position: relative;
      background: radial-gradient(circle at center, rgba(19, 10, 4, 0.86), rgba(13, 7, 3, 0.94));
      border-radius: 26px;
      padding: 28px 28px 60px;
      box-shadow: inset 0 0 28px rgba(0, 0, 0, 0.55), 0 24px 50px rgba(0, 0, 0, 0.55);
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      touch-action: pan-y;
    }
    #message {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    #messageContent {
      pointer-events: auto;
      background: rgba(17, 10, 4, 0.94);
      padding: 32px 40px;
      border: 1px solid rgba(244, 215, 140, 0.8);
      border-radius: 18px;
      box-shadow: 0 22px 36px rgba(0, 0, 0, 0.6);
      text-align: center;
      min-width: 280px;
    }
    #messageText {
      margin-bottom: 16px;
      font-size: 20px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #ffecc4;
    }
    #testout {
      position: absolute;
      bottom: 12px;
      left: 18px;
      background: rgba(0, 0, 0, 0.58);
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 11px;
      max-width: 60ch;
      line-height: 1.3;
      pointer-events: none;
      color: rgba(255, 255, 255, 0.72);
    }
    @media (max-width: 780px) {
      #hud {
        flex-direction: column;
        gap: 18px;
        align-items: stretch;
      }
      #status {
        justify-content: center;
      }
      #boardArea {
        padding: 22px 18px 48px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header id="hud">
      <div id="identity">
        <div>Devil's Six</div>
        <div class="subtitle">Churchill Solitaire</div>
      </div>
      <div id="ui">
        <button id="newGame" class="btn">New Deal</button>
        <button id="deal" class="btn">Deal</button>
        <button id="hint" class="btn">Hint</button>
        <button id="undo" class="btn">Undo</button>
      </div>
      <div id="status">
        <div>Time <span id="time">00:00</span></div>
        <div>Deals <span id="deals">0</span></div>
        <div>Career <span id="careerScore">0</span></div>
      </div>
    </header>
    <main id="boardArea">
      <canvas id="game"></canvas>
      <div id="message">
        <div id="messageContent">
          <div id="messageText"></div>
          <button id="playAgain" class="btn">Play Again</button>
        </div>
      </div>
      <div id="testout"></div>
    </main>
  </div>

  <script>
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
  const COLORS = { '\u2660':'black', '\u2663':'black', '\u2665':'red', '\u2666':'red' };
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL  = { A:1, J:11, Q:12, K:13 };
  for (let i=2;i<=10;i++) RVAL[i]=i;
  const PADDING = 36;

  class Card {
    constructor(suit, rank){
      this.suit = suit;
      this.rank = rank;
      this.value = RVAL[rank];
      this.color = COLORS[suit];
      this.faceUp = false;
    }
  }

  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]);
  let stock = [];
  let deck = [];
  let deals = 0;
  let timeStart = 0;
  let timer = null;
  let undoStack = [];
  let career = +localStorage.getItem('careerScore') || 0;
  document.getElementById('careerScore').textContent = career;

  // ★ NEW: track which tableau columns have had a king planted
  let anchoredCols = new Array(10).fill(false);

  let CARD_W = 80, CARD_H = 120, OVERLAP = 26;
  let boardWidth = 0;
  let boardHeight = 0;

  const TopGeom = {
    dsX: PADDING,
    dsY: PADDING,
    dsGap: 18,
    stockX: 0,
    stockY: 0,
    fSlots: [],
    fCols: 4,
    fRows: 2,
    fGapX: 10,
    fGapY: 8,
    fY: PADDING
  };

  function layout(w){
    CARD_W = Math.max(56, Math.min(94, Math.floor((w - PADDING * 2) / 14)));
    CARD_H = Math.floor(CARD_W * 1.52);
    OVERLAP = Math.floor(CARD_H * 0.22);
  }
  function tableauGutter(){
    const available = boardWidth - PADDING * 2 - CARD_W * 10;
    return Math.max(6, Math.floor(available / 9));
  }
  function colX(c){ return PADDING + c * (CARD_W + tableauGutter()); }
  function tableauTopY(){
    const top = TopGeom.fY + (CARD_H * TopGeom.fRows) + (TopGeom.fGapY * (TopGeom.fRows - 1)) + 42;
    return Math.max(top, CARD_H + 52);
  }
  function computeTopGeometry(){
    TopGeom.dsY = PADDING;
    TopGeom.dsGap = Math.max(Math.floor(CARD_W * 0.16), 14);
    TopGeom.fGapX = Math.max(Math.floor(CARD_W * 0.18), 14);
    TopGeom.fGapY = Math.max(Math.floor(CARD_H * 0.1), 14);
    TopGeom.stockX = PADDING;
    TopGeom.stockY = TopGeom.dsY;
    const dsWidth = CARD_W * Math.max(devilsSix.length, 6) + TopGeom.dsGap * (Math.max(devilsSix.length, 6) - 1);
    TopGeom.dsX = TopGeom.stockX + CARD_W + Math.max(28, Math.floor(CARD_W * 0.6));

    const totalFW = TopGeom.fCols * CARD_W + (TopGeom.fCols - 1) * TopGeom.fGapX;
    const minStart = TopGeom.dsX + dsWidth + Math.max(30, Math.floor(CARD_W * 0.7));
    let startX = boardWidth - PADDING - totalFW;
    if (startX < minStart){
      startX = Math.max(PADDING, Math.min(minStart, boardWidth - PADDING - totalFW));
    }
    startX = Math.max(PADDING, startX);
    TopGeom.fSlots = [];
    for (let row=0; row<TopGeom.fRows; row++){
      for (let col=0; col<TopGeom.fCols; col++){
        const x = startX + col*(CARD_W + TopGeom.fGapX);
        const y = TopGeom.fY + row*(CARD_H + TopGeom.fGapY);
        TopGeom.fSlots.push({x,y});
      }
    }
  }
  function computeBoardHeight(){
    const tTop = tableauTopY();
    let tallest = 1;
    for (let i=0;i<tableau.length;i++){
      tallest = Math.max(tallest, tableau[i].length);
    }
    return Math.max(window.innerHeight * 0.82, tTop + (tallest - 1) * OVERLAP + CARD_H + PADDING);
  }
  function syncBoardMetrics(){
    const width = canvas.clientWidth || canvas.parentElement.clientWidth || window.innerWidth;
    boardWidth = width;
    layout(width);
    computeTopGeometry();
    const desiredHeight = computeBoardHeight();
    if (Math.abs(desiredHeight - boardHeight) > 1){
      boardHeight = desiredHeight;
      canvas.style.height = `${boardHeight}px`;
    }
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(boardHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  function render(){
    syncBoardMetrics();
    draw();
  }
  function resizeCanvas(){
    render();
  }
  window.addEventListener('resize', resizeCanvas);

  let stockHit = {x:0,y:0,w:0,h:0};
  let drag = null;
  let mouseX = 0, mouseY = 0;

  function drawRoundRect(x,y,w,h,r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawCard(card,x,y,opts={}){
    const {highlight=false,empty=false,suitHint=null,ghost=false} = opts;
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = ghost ? 0.85 : 1;
    const radius = Math.max(8, CARD_W * 0.16);
    if (card){
      ctx.shadowColor = 'rgba(0,0,0,0.42)';
      ctx.shadowBlur = Math.max(12, CARD_W * 0.25);
      ctx.shadowOffsetY = Math.max(4, CARD_H * 0.08);
      const shellGradient = ctx.createLinearGradient(0,0,0,CARD_H);
      if (card.faceUp){
        shellGradient.addColorStop(0, '#faf8f4');
        shellGradient.addColorStop(0.5, '#ffffff');
        shellGradient.addColorStop(1, '#ece7dc');
      } else {
        shellGradient.addColorStop(0, '#26418f');
        shellGradient.addColorStop(1, '#152458');
      }
      ctx.fillStyle = shellGradient;
      drawRoundRect(0,0,CARD_W,CARD_H,radius);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      drawRoundRect(0,0,CARD_W,CARD_H,radius);
      ctx.lineWidth = card.faceUp ? 1.6 : 1.8;
      ctx.strokeStyle = card.faceUp ? '#151515' : '#0a163a';
      ctx.stroke();

      if (card.faceUp){
        const insetRadius = Math.max(6, CARD_W * 0.12);
        drawRoundRect(6,6,CARD_W-12,CARD_H-12,insetRadius);
        const faceGradient = ctx.createLinearGradient(6,6,CARD_W-6,CARD_H-6);
        faceGradient.addColorStop(0, 'rgba(255,255,255,0.9)');
        faceGradient.addColorStop(1, 'rgba(236,233,220,0.85)');
        ctx.fillStyle = faceGradient;
        ctx.fill();

        ctx.fillStyle = card.color === 'red' ? '#c93434' : '#111111';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.font = `700 ${Math.floor(CARD_W/4.1)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.rank, Math.floor(CARD_W*0.12), Math.floor(CARD_H*0.08));
        ctx.font = `${Math.floor(CARD_W/4.8)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.suit, Math.floor(CARD_W*0.12), Math.floor(CARD_H*0.32));

        ctx.save();
        ctx.translate(CARD_W - Math.floor(CARD_W*0.12), CARD_H - Math.floor(CARD_H*0.08));
        ctx.rotate(Math.PI);
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.font = `700 ${Math.floor(CARD_W/4.1)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.rank, 0, 0);
        ctx.font = `${Math.floor(CARD_W/4.8)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.suit, 0, Math.floor(CARD_H*0.24));
        ctx.restore();

        ctx.save();
        ctx.translate(CARD_W/2, CARD_H/2);
        ctx.font = `600 ${Math.floor(CARD_W/1.9)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = card.color === 'red' ? '#d04747' : '#1f1f1f';
        ctx.fillText(card.suit, 0, 0);
        ctx.restore();
      } else {
        const insetRadius = Math.max(6, CARD_W * 0.12);
        drawRoundRect(6,6,CARD_W-12,CARD_H-12,insetRadius);
        ctx.save();
        ctx.clip();
        const patternSize = Math.max(14, Math.floor(CARD_W/5));
        for (let yy=-patternSize; yy<CARD_H+patternSize; yy+=patternSize){
          for (let xx=-patternSize; xx<CARD_W+patternSize; xx+=patternSize){
            ctx.fillStyle = '#1e3080';
            ctx.fillRect(xx,yy,patternSize,patternSize);
            ctx.fillStyle = '#314ca8';
            ctx.fillRect(xx,yy,patternSize/2,patternSize/2);
            ctx.fillRect(xx+patternSize/2,yy+patternSize/2,patternSize/2,patternSize/2);
          }
        }
        ctx.restore();
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.stroke();
      }

      if (highlight){
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffd86b';
        drawRoundRect(1.5,1.5,CARD_W-3,CARD_H-3, Math.max(6, radius-2));
        ctx.stroke();
      }
    } else {
      ctx.setLineDash([7,7]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(237, 202, 120, 0.8)';
      drawRoundRect(0.5,0.5,CARD_W-1,CARD_H-1,radius);
      ctx.stroke();
      ctx.setLineDash([]);
      if (suitHint){
        ctx.fillStyle = 'rgba(255,255,255,0.22)';
        ctx.font = `700 ${Math.floor(CARD_W/3.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('A'+suitHint, CARD_W/2, CARD_H/2);
      }
    }
    ctx.restore();
  }

  function draw(){
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    const dsSlots = Math.max(devilsSix.length, 6);
    for (let i=0;i<dsSlots;i++){
      const isDraggingDevil = drag && drag.from.type === 'devils' && drag.from.idx === i;
      const card = (!isDraggingDevil && devilsSix[i]) ? devilsSix[i] : null;
      drawCard(card, TopGeom.dsX + i*(CARD_W + TopGeom.dsGap), TopGeom.dsY, {empty:!card});
    }
    drawCard(stock.length ? {faceUp:false} : null, TopGeom.stockX, TopGeom.stockY);
    stockHit = {x:TopGeom.stockX, y:TopGeom.stockY, w:CARD_W, h:CARD_H};

    for (let i=0;i<8;i++){
      const slot = TopGeom.fSlots[i];
      const stack = foundations[i];
      const top = stack.length ? stack[stack.length-1] : null;
      drawCard(top, slot.x, slot.y, {empty:!top, suitHint:SUITS[i%4]});
    }

    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const x = colX(c);
      const col = tableau[c];
      if (!col.length){
        drawCard(null,x,tY);
        continue;
      }
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
        drawCard(card, x, tY + i*OVERLAP);
      }
    }

    if (drag){
      for (let i=0;i<drag.cards.length;i++){
        drawCard(drag.cards[i], mouseX - CARD_W/2, mouseY - CARD_H/2 + i*OVERLAP, {ghost:true,highlight:true});
      }
    }
  }

  function hitAt(x,y){
    for (let i=0;i<8;i++){
      const s = TopGeom.fSlots[i];
      if (x>s.x && x<s.x+CARD_W && y>s.y && y<s.y+CARD_H)
        return {type:'foundation', idx:i};
    }
    for (let i=0;i<devilsSix.length;i++){
      const dx = TopGeom.dsX + i*(CARD_W + TopGeom.dsGap), dy=TopGeom.dsY;
      if (x>dx && x<dx+CARD_W && y>dy && y<dy+CARD_H)
        return {type:'devils', idx:i};
    }
    if (stock.length && x>stockHit.x && x<stockHit.x+CARD_W && y>stockHit.y && y<stockHit.y+CARD_H)
      return {type:'stock'};

    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const cx = colX(c);
      const col = tableau[c];
      if (!col.length){
        if (x>cx && x<cx+CARD_W && y>tY && y<tY+CARD_H) return {type:'tableau', col:c, row:-1};
        continue;
      }
      for (let i=col.length-1;i>=0;i--){
        const cy = tY + i*OVERLAP;
        if (x>cx && x<cx+CARD_W && y>cy && y<cy+CARD_H)
          return {type:'tableau', col:c, row:i};
      }
    }
    return null;
  }

  function getRunLength(col, start){
    const arr = tableau[col];
    let len = 1;
    for (let i=start+1;i<arr.length;i++){
      const prev = arr[i-1], cur = arr[i];
      if (!cur.faceUp) break;
      if (prev.color === cur.color) break;
      if (cur.value !== prev.value - 1) break;
      len++;
    }
    return len;
  }
  function canPlaceOnTableau(card, toCol){
    const col = tableau[toCol];
    const top = col[col.length-1];
    if (!top) return card.value === 13;
    return (card.color !== top.color) && (card.value === top.value - 1);
  }
  function canPlaceOnFoundation(card, fIdx){
    if (SUITS[fIdx % 4] !== card.suit) return false;
    const stack = foundations[fIdx];
    const top   = stack[stack.length-1];
    return top ? (card.value === top.value + 1) : (card.value === 1);
  }
  function flipTop(col){
    const colArr = tableau[col];
    if (colArr.length && !colArr[colArr.length-1].faceUp)
      colArr[colArr.length-1].faceUp = true;
  }
  function canStartDragAt(col, row){
    const colArr = tableau[col];
    if (row < 0 || row >= colArr.length) return false;
    const card = colArr[row];
    if (!card.faceUp) return false;
    return true;
  }

  // ===== DEAL =====
  function doDeal(){
    if (!stock.length) {
      render();
      updateUI();
      return;
    }

    // if ALL columns are anchored-by-king, don't deal
    let allAnchored = true;
    for (let c=0;c<10;c++){
      if (!anchoredCols[c]) {
        allAnchored = false;
        break;
      }
    }
    if (allAnchored) {
      render();
      updateUI();
      return;
    }

    const dealt = [];
    for (let c=0;c<10;c++){
      if (!stock.length) break;
      // ★ skip permanently anchored columns
      if (anchoredCols[c]) continue;

      const col = tableau[c];
      const card = stock.pop();
      if (!card) break;
      card.faceUp = true;
      col.push(card);
      dealt.push({col:c, card});
    }

    if (!dealt.length){
      render();
      updateUI();
      return;
    }

    deals++;
    document.getElementById('deals').textContent = deals;
    undoStack.push({kind:'deal', payload:dealt});
    render();
    updateUI();
    checkWinOrStuck();
  }

  function hasAnyMoves(){
    for (let c=0;c<10;c++){
      const top = tableau[c][tableau[c].length-1];
      if (!top) continue;
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(top,f)) return true;
    }
    for (const card of devilsSix){
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(card,f)) return true;
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      const start = col.findIndex(c=>c.faceUp);
      if (start<0) continue;
      for (let i=start;i<col.length;i++){
        const base = col[i];
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(base,to)) return true;
        }
      }
    }
    return false;
  }
  function checkWinOrStuck(){
    const total = foundations.reduce((n,s)=>n+s.length,0);
    if (total === 104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      finishGame(true);
      return;
    }
    if (!stock.length && !hasAnyMoves()){
      finishGame(false);
    }
  }
  function finishGame(win){
    if (win){
      const secs = Math.floor((Date.now()-timeStart)/1000);
      const score = Math.max(50, 1000 - deals*100 - Math.floor(secs/10));
      career += score;
      localStorage.setItem('careerScore', career);
      document.getElementById('careerScore').textContent = career;
      showMessage('Victory! Foundations complete.');
    } else {
      showMessage('No more moves.');
    }
  }

  function buildDeck(){
    const temp = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          temp.push(new Card(s,r));
        }
      }
    }
    for (let i=temp.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [temp[i], temp[j]] = [temp[j], temp[i]];
    }
    deck = temp;
  }
  function newGame(){
    buildDeck();
    tableau = new Array(10).fill(0).map(()=>[]);
    devilsSix = [];
    foundations = new Array(8).fill(0).map(()=>[]);
    stock = [];
    undoStack = [];
    // ★ reset anchored columns
    anchoredCols = new Array(10).fill(false);

    for (let i=0;i<6;i++){
      const c = deck.pop();
      c.faceUp = true;
      devilsSix.push(c);
    }

    const downs = [0,1,2,3,4,4,3,2,1,0];
    for (let col=0; col<10; col++){
      for (let d=0; d<downs[col]; d++){
        const c = deck.pop();
        c.faceUp = false;
        tableau[col].push(c);
      }
      const up = deck.pop();
      up.faceUp = true;
      tableau[col].push(up);
    }

    stock = deck;
    deals = 0;
    document.getElementById('deals').textContent = deals;

    timeStart = Date.now();
    if (timer) clearInterval(timer);
    timer = setInterval(()=>{
      const s = Math.floor((Date.now()-timeStart)/1000);
      const m = (s/60|0).toString().padStart(2,'0');
      const ss = (s%60).toString().padStart(2,'0');
      document.getElementById('time').textContent = `${m}:${ss}`;
    },1000);

    updateUI();
    render();
  }

  function updateUI(disable=false){
    document.getElementById('deal').disabled = disable || stock.length===0;
    document.getElementById('undo').disabled = disable || undoStack.length===0;
    document.getElementById('hint').disabled = disable;
  }
  function showMessage(t){
    document.getElementById('messageText').textContent = t;
    document.getElementById('message').style.display = 'flex';
    updateUI(true);
    if (timer) clearInterval(timer);
  }
  function hideMessage(){ document.getElementById('message').style.display = 'none'; }

  function getCanvasPos(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  function handlePrimaryMove(x, y){
    mouseX = x;
    mouseY = y;
    if (drag) draw();
  }

  function handlePrimaryDown(x, y){
    mouseX = x;
    mouseY = y;
    const hit = hitAt(x, y);
    if (!hit) return false;

    if (hit.type === 'stock'){
      doDeal();
      return true;
    }

    if (hit.type === 'tableau' && hit.row >= 0){
      const card = tableau[hit.col][hit.row];
      if (card && card.faceUp && card.value === 1){
        const candidates = [];
        for (let f=0;f<8;f++) if (SUITS[f%4] === card.suit) candidates.push(f);
        let placed = false;
        for (const f of candidates){
          if (foundations[f].length === 0){
            foundations[f].push(card);
            tableau[hit.col].splice(hit.row,1);
            flipTop(hit.col);
            undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card});
            placed = true;
            break;
          }
        }
        if (!placed){
          for (const f of candidates){
            if (canPlaceOnFoundation(card, f)){
              foundations[f].push(card);
              tableau[hit.col].splice(hit.row,1);
              flipTop(hit.col);
              undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card});
              placed = true;
              break;
            }
          }
        }
        if (placed){
          render();
          updateUI();
          checkWinOrStuck();
          return true;
        }
      }
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      if (card && card.value === 1){
        const candidates = [];
        for (let f=0;f<8;f++) if (SUITS[f%4] === card.suit) candidates.push(f);
        let placed = false;
        for (const f of candidates){
          if (foundations[f].length === 0){
            foundations[f].push(card);
            devilsSix.splice(hit.idx,1);
            undoStack.push({kind:'toFound', from:{type:'devils',idx:hit.idx}, fIdx:f, card});
            placed = true;
            break;
          }
        }
        if (!placed){
          for (const f of candidates){
            if (canPlaceOnFoundation(card, f)){
              foundations[f].push(card);
              devilsSix.splice(hit.idx,1);
              undoStack.push({kind:'toFound', from:{type:'devils',idx:hit.idx}, fIdx:f, card});
              placed = true;
              break;
            }
          }
        }
        if (placed){
          render();
          updateUI();
          checkWinOrStuck();
          return true;
        }
      }
    }

    if (hit.type === 'tableau'){
      if (hit.row < 0) return false;
      if (!canStartDragAt(hit.col, hit.row)) return false;
      const runLen = getRunLength(hit.col, hit.row);
      drag = {
        from: {type:'tableau', col:hit.col, idx:hit.row},
        cards: tableau[hit.col].slice(hit.row, hit.row + runLen)
      };
      draw();
      return true;
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      drag = {from:{type:'devils', idx:hit.idx}, cards:[card]};
      draw();
      return true;
    }

    return false;
  }

  function handlePrimaryUp(x, y){
    if (!drag){
      mouseX = x;
      mouseY = y;
      return;
    }
    mouseX = x;
    mouseY = y;
    const drop = hitAt(mouseX, mouseY);
    const moving = drag.cards[0];
    let moved = false;

    if (drop){
      // to foundation
      if (drop.type === 'foundation' && drag.cards.length === 1 && canPlaceOnFoundation(moving, drop.idx)){
        foundations[drop.idx].push(moving);
        if (drag.from.type === 'tableau'){
          tableau[drag.from.col].splice(drag.from.idx,1);
          flipTop(drag.from.col);
        } else {
          devilsSix.splice(drag.from.idx,1);
        }
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        moved = true;
      }
      // tableau-to-tableau
      else if (drop.type === 'tableau' && drag.from.type === 'tableau' && canPlaceOnTableau(moving, drop.col)){
        const run = drag.cards.slice();
        const toCol = drop.col;
        const fromCol = drag.from.col;

        const wasAnchoredBefore = anchoredCols[toCol]; // ★ capture old state

        tableau[toCol].push(...run);
        tableau[fromCol].splice(drag.from.idx, run.length);
        flipTop(fromCol);

        // ★ if we placed a KING onto an EMPTY column, per your rule, anchor it forever
        if (wasAnchoredBefore === false && tableau[toCol].length === run.length) {
          // column was empty before this move
          if (run[0].faceUp && run[0].value === 13) {
            anchoredCols[toCol] = true;
          }
        }

        undoStack.push({
          kind:'tab2tab',
          from:{col:fromCol, idx:drag.from.idx},
          toCol:toCol,
          count:run.length,
          // ★ store previous anchor state so undo can restore it
          prevAnchored: wasAnchoredBefore
        });
        moved = true;
      }
      else if (drop.type === 'tableau' && drag.from.type === 'devils' && canPlaceOnTableau(moving, drop.col)){
        const toCol = drop.col;
        const prevAnchored = anchoredCols[toCol];
        tableau[toCol].push(moving);
        devilsSix.splice(drag.from.idx,1);
        if (prevAnchored === false && tableau[toCol].length === 1 && moving.faceUp && moving.value === 13){
          anchoredCols[toCol] = true;
        }
        undoStack.push({
          kind:'devils2tab',
          toCol,
          fromIdx: drag.from.idx,
          prevAnchored
        });
        moved = true;
      }
    }

    drag = null;
    render();
    if (moved){
      updateUI();
      checkWinOrStuck();
    }
  }

  function cancelDrag(){
    if (drag){
      drag = null;
      render();
    }
  }

  canvas.addEventListener('contextmenu', e=> e.preventDefault());

  const supportsPointer = 'PointerEvent' in window;
  if (supportsPointer){
    let activePointerId = null;
    const isPrimaryPointer = e => {
      if (e.pointerType === 'mouse') return e.button === 0;
      return true;
    };
    canvas.addEventListener('pointerdown', e=>{
      if (activePointerId !== null) return;
      if (!isPrimaryPointer(e)) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      const startedDrag = !!drag;
      if (startedDrag){
        try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
        activePointerId = e.pointerId;
      }
      if (handled && e.pointerType !== 'mouse') e.preventDefault();
    }, {passive:false});
    canvas.addEventListener('pointermove', e=>{
      if (activePointerId !== e.pointerId) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryMove(pos.x, pos.y);
      if (drag && e.pointerType !== 'mouse') e.preventDefault();
    }, {passive:false});
    const finishPointer = e=>{
      if (activePointerId !== e.pointerId) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryUp(pos.x, pos.y);
      activePointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      if (e.pointerType !== 'mouse') e.preventDefault();
    };
    canvas.addEventListener('pointerup', finishPointer, {passive:false});
    window.addEventListener('pointerup', finishPointer, {passive:false});
    const cancelPointer = e=>{
      if (activePointerId !== e.pointerId) return;
      activePointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      cancelDrag();
      if (e.pointerType !== 'mouse') e.preventDefault();
    };
    canvas.addEventListener('pointercancel', cancelPointer, {passive:false});
    window.addEventListener('pointercancel', cancelPointer, {passive:false});
    canvas.addEventListener('lostpointercapture', e=>{
      if (activePointerId !== e.pointerId) return;
      activePointerId = null;
      cancelDrag();
    });
  } else {
    canvas.addEventListener('mousemove', e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryMove(pos.x, pos.y);
    });
    canvas.addEventListener('mousedown', e=>{
      if (e.button !== 0) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      if (handled) e.preventDefault();
    });
    window.addEventListener('mouseup', e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryUp(pos.x, pos.y);
    });

    let activeTouchId = null;
    canvas.addEventListener('touchstart', e=>{
      if (activeTouchId !== null) return;
      const touch = e.changedTouches[0];
      if (!touch) return;
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      const startedDrag = !!drag;
      if (!handled) return;
      if (startedDrag) {
        activeTouchId = touch.identifier;
      }
      e.preventDefault();
    }, {passive:false});
    window.addEventListener('touchmove', e=>{
      if (activeTouchId === null) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (touch.identifier === activeTouchId){
          const pos = getCanvasPos(touch.clientX, touch.clientY);
          handlePrimaryMove(pos.x, pos.y);
          if (drag) e.preventDefault();
          break;
        }
      }
    }, {passive:false});
    const finishTouch = e=>{
      if (activeTouchId === null) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (touch.identifier === activeTouchId){
          const pos = getCanvasPos(touch.clientX, touch.clientY);
          handlePrimaryUp(pos.x, pos.y);
          activeTouchId = null;
          e.preventDefault();
          break;
        }
      }
    };
    window.addEventListener('touchend', finishTouch, {passive:false});
    window.addEventListener('touchcancel', e=>{
      if (activeTouchId === null) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (touch.identifier === activeTouchId){
          activeTouchId = null;
          cancelDrag();
          break;
        }
      }
    });
  }

  document.getElementById('undo').addEventListener('click', ()=>{
    if (!undoStack.length) return;
    const step = undoStack.pop();
    if (step.kind === 'deal'){
      for (let i=step.payload.length-1;i>=0;i--){
        const {col,card} = step.payload[i];
        tableau[col].pop();
        card.faceUp = false;
        stock.push(card);
      }
      deals = Math.max(0, deals-1);
      document.getElementById('deals').textContent = deals;
    } else if (step.kind === 'tab2tab'){
      const moved = tableau[step.toCol].splice(-step.count, step.count);
      tableau[step.from.col].splice(step.from.idx, 0, ...moved);
      flipTop(step.from.col);
      // ★ restore anchored flag for target column
      if (typeof step.prevAnchored === 'boolean') {
        anchoredCols[step.toCol] = step.prevAnchored;
      }
    } else if (step.kind === 'devils2tab'){
      const card = tableau[step.toCol].pop();
      if (card){
        devilsSix.splice(step.fromIdx,0,card);
      }
      if (typeof step.prevAnchored === 'boolean') {
        anchoredCols[step.toCol] = step.prevAnchored;
      }
    } else if (step.kind === 'toFound'){
      const card = foundations[step.fIdx].pop();
      if (step.from.type === 'tableau'){
        tableau[step.from.col].splice(step.from.idx,0,card);
      } else {
        devilsSix.splice(step.from.idx,0,card);
      }
    }
    render();
    updateUI();
  });

  function hint(){
    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const col = tableau[c];
      const top = col[col.length-1];
      if (!top) continue;
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(top,f)){
          flash(()=>{ drawCard(top, colX(c), tY + (col.length-1)*OVERLAP, {highlight:true}); });
          return;
        }
      }
    }
    for (let i=0;i<devilsSix.length;i++){
      const card = devilsSix[i];
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(card,f)){
          flash(()=>{ drawCard(card, TopGeom.dsX + i*(CARD_W + TopGeom.dsGap), TopGeom.dsY, {highlight:true}); });
          return;
        }
      }
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (!card.faceUp) continue;
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(card,to)){
            flash(()=>{ drawCard(card, colX(from), tY + i*OVERLAP, {highlight:true}); });
            return;
          }
        }
      }
    }
  }
  function flash(paint){
    let n=0;
    const id=setInterval(()=>{
      render();
      if (n%2===0) paint();
      if (++n>5) clearInterval(id);
    },120);
  }

  document.getElementById('newGame').addEventListener('click', ()=>{ hideMessage(); newGame(); });
  document.getElementById('deal').addEventListener('click', doDeal);
  document.getElementById('hint').addEventListener('click', hint);
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideMessage(); newGame(); });

  function runTests(){
    const results = [];
    results.push(['8 foundations', Array.isArray(foundations) && foundations.length === 8]);
    results.push(['10 tableau columns', Array.isArray(tableau) && tableau.length === 10]);
    results.push(['Devil’s Six is 6 cards', Array.isArray(devilsSix) && devilsSix.length === 6]);
    results.push(['Devil’s Six faceup', devilsSix.every(c => c && c.faceUp)]);
    const failed = results.filter(r=>!r[1]);
    const el = document.getElementById('testout');
    if (el){
      el.textContent = failed.length
        ? `Tests: ${results.length - failed.length}/${results.length} passed, ${failed.length} failed`
        : `Tests: ${results.length} passed`;
    }
  }

  resizeCanvas();
  newGame();
  runTests();
  </script>
</body>
</html>
