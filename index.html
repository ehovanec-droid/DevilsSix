<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Churchill Solitaire (Devilâ€™s Six)</title>
  <style>
    :root {
      --bg: #2f241b; --ink: #f2eee8; --muted:#c9c1ba;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #ui{position:fixed;inset:0 0 auto 0;padding:8px 12px;background:linear-gradient(180deg,rgba(0,0,0,.55),rgba(0,0,0,0));z-index:10;pointer-events:none}
    #ui .row{display:flex;align-items:center;justify-content:space-between;gap:12px;pointer-events:auto;height:44px}
    button{background:#1f2937;color:var(--ink);border:1px solid #2b3a4a;border-radius:10px;padding:8px 12px;cursor:pointer}
    button:hover{filter:brightness(1.1)}
    #status{color:var(--muted)}
    #game{position:fixed;inset:0;display:block;outline:none;background:#3b2a1f}
    .modal{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.55)}
    .hidden{display:none}
    .modal-body{background:#0f172a;color:var(--ink);border:1px solid #2b3a4a;padding:24px;border-radius:16px;min-width:260px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.4)}
    .modal-body h2{margin-top:0}
  </style>
</head>
<body>
  <div id="ui">
    <div class="row">
      <div class="left">
        <button id="btnNew">New Game</button>
        <button id="btnDeal">Deal</button>
        <button id="btnUndo">Undo</button>
      </div>
      <div class="center"><span id="status">Erik's Devil's Six â€” ready</span></div>
      <div class="right">
        <label style="user-select:none;color:var(--muted);font-size:14px">
          <input type="checkbox" id="cbPortrait" /> Portrait
        </label>
      </div>
    </div>
  </div>

  <canvas id="game" tabindex="0" aria-label="Churchill Solitaire canvas"></canvas>

  <div id="winModal" class="modal hidden"><div class="modal-body">
    <h2>You Win!</h2><p>All cards to foundations. ðŸŽ‰</p>
    <button id="btnPlayAgain">Play again</button>
  </div></div>

  <div id="loseModal" class="modal hidden"><div class="modal-body">
    <h2>No Moves</h2><p>Stock is empty and no valid moves remain.</p>
    <button id="btnRetry">New game</button>
  </div></div>

  <script>
  (() => {
    // ======= Config / constants =======
    const RULES = {
      name: "Erik's Devil's Six",
      decks: 2, tableauColumns: 10, foundations: 8, reserves: 6,
      card: { w: 96, h: 136, corner: 10, pad: 14, fanY: 26, scaleMin: 0.6 },
      reserveGap: 26, feltInsets: { x: 24, y: 72 },
    };
    const SUITS = ['â™ ','â™¥','â™¦','â™£'];
    const COLORS = { 'â™ ':'black','â™£':'black','â™¥':'red','â™¦':'red' };
    const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    const rankIndex = r => RANKS.indexOf(r);
    const isAltColor = (a,b)=> COLORS[a.s] !== COLORS[b.s];

    // ======= Canvas / state =======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const state = {
      cards: [], piles: {}, panels: {},
      layout: { portrait:false, scale:1 },
      drag: null, undo: [], won:false, lost:false,
      pileHighlights: new Set(),
    };

    // ======= Helpers =======
    function makeDeck(n=1){
      const out=[];
      for (let d=0; d<n; d++)
        for (const s of SUITS) for (const r of RANKS)
          out.push({ id:`${d}-${s}-${r}-${Math.random().toString(36).slice(2,7)}`, s, r, faceUp:false, x:0,y:0,z:0, pile:null });
      return out;
    }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

    // ======= Layout & drawing =======
    function resize(){
      const W = window.innerWidth, H = window.innerHeight;
      canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
      canvas.style.width = W+"px"; canvas.style.height = H+"px";
      ctx.setTransform(DPR,0,0,DPR,0,0);

      const cbPortrait = document.getElementById('cbPortrait');
      state.layout.portrait = cbPortrait.checked || (H>W);

      const { w,h,fanY,scaleMin } = RULES.card;
      const cols = state.layout.portrait ? Math.ceil(RULES.tableauColumns/2) : RULES.tableauColumns;
      const availableW = W - RULES.feltInsets.x*2;
      const neededW = cols*w + (cols-1)*16;
      let scale = Math.min(1, availableW/neededW);
      const availableH = H - RULES.feltInsets.y*2 - 80;
      scale = Math.max(scaleMin, Math.min(scale, (h + 13*fanY)/availableH));
      state.layout.scale = scale;
    }

    function roundRect(x,y,w,h,r){
      const rr = Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawCard(c){
      const { w,h,corner } = RULES.card, s = state.layout.scale;
      const x=c.x, y=c.y;
      ctx.save(); ctx.translate(x,y); ctx.scale(s,s);
      roundRect(0,0,w,h,corner); ctx.fillStyle='#fff'; ctx.fill(); ctx.lineWidth=1.5; ctx.strokeStyle='#cfd8e3'; ctx.stroke();
      if (c.faceUp){
        const color = (COLORS[c.s]==='red') ? '#d7263d' : '#111827';
        ctx.fillStyle=color; ctx.font='bold 18px system-ui'; ctx.textBaseline='top';
        ctx.fillText(c.r,8,8); ctx.fillText(c.s,8,28);
        ctx.textAlign='right'; ctx.textBaseline='bottom'; ctx.fillText(c.r,w-8,h-8); ctx.fillText(c.s,w-8,h-28);
      } else {
        roundRect(6,6,w-12,h-12,8); ctx.fillStyle='#081a3a'; ctx.fill();
        ctx.globalAlpha=.22; ctx.fillStyle='#e9f0ff';
        for (let yy=12; yy<h-12; yy+=12) for (let xx=12; xx<w-12; xx+=24) ctx.fillRect(xx,yy,12,6);
        ctx.globalAlpha=1;
      }
      ctx.restore();
    }

    function drawPileType(type, draggingSet){
      for (const p of Object.values(state.piles)){
        if (p.type!==type) continue;
        for (let i=0;i<p.cards.length;i++){
          const c=p.cards[i]; if (draggingSet.has(c.id)) continue; drawCard(c);
        }
      }
    }

    function render(){
      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.clearRect(0,0,W,H);

      // Title
      ctx.save(); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.font='700 18px system-ui';
      ctx.textBaseline='top'; ctx.fillText("Erik's Devil's Six", RULES.feltInsets.x, RULES.feltInsets.y-4); ctx.restore();

      // Panels
      const stroke='rgba(255,255,255,.14)', fill='rgba(0,0,0,.10)';
      for (const p of Object.values(state.panels)){ ctx.save(); ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=2;
        roundRect(p.x,p.y,p.w,p.h,12); ctx.fill(); ctx.stroke(); ctx.restore(); }

      // Pile guides + highlights
      const s = state.layout.scale, {w,h,corner} = RULES.card;
      for (const [key,p] of Object.entries(state.piles)){
        ctx.globalAlpha=.10; ctx.fillStyle='#e9eef6'; roundRect(p.x,p.y,w*s,h*s,corner*s); ctx.fill();
        if (state.pileHighlights.has(key)){ ctx.globalAlpha=.9; ctx.lineWidth=4; ctx.strokeStyle='#6aa7ff'; roundRect(p.x-2,p.y-2,w*s+4,h*s+4,corner*s+2); ctx.stroke(); }
      }
      ctx.globalAlpha=1;

      const dragging = new Set((state.drag?.cards||[]).map(c=>c.id));
      drawPileType('tableau', dragging);
      drawPileType('foundation', dragging);
      drawPileType('reserve', dragging);
      drawPileType('stock', dragging);

      if (state.drag?.cards) for (const c of state.drag.cards) drawCard(c);
    }

    // ======= Hit-testing =======
    function hitCard(px,py){
      const order=['reserve','stock','foundation','tableau'];
      const s=state.layout.scale, {w,h}=RULES.card;
      if (state.drag?.cards){
        for (let i=state.drag.cards.length-1;i>=0;i--){
          const c=state.drag.cards[i]; const rx=px-c.x, ry=py-c.y; if (rx>=0&&ry>=0&&rx<=w*s&&ry<=h*s) return c;
        }
      }
      for (const type of order){
        for (const p of Object.values(state.piles)){
          if (p.type!==type) continue;
          for (let i=p.cards.length-1;i>=0;i--){
            const c=p.cards[i]; const rx=px-c.x, ry=py-c.y; if (rx>=0&&ry>=0&&rx<=w*s&&ry<=h*s) return c;
          }
        }
      }
      return null;
    }
    function hitPile(px,py){ const s=state.layout.scale,{w,h}=RULES.card; for (const [k,p] of Object.entries(state.piles)){ if (px>=p.x&&py>=p.y&&px<=p.x+w*s&&py<=p.y+h*s) return p; } return null; }
    function pileKey(p){ for (const [k,v] of Object.entries(state.piles)) if (v===p) return k; return null; }
    function getPoint(e){ const r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }

    // ======= Input =======
    canvas.addEventListener('pointerdown', onDown, {passive:false});
    canvas.addEventListener('pointermove', onMove, {passive:false});
    canvas.addEventListener('pointerup', onUp, {passive:false});
    canvas.addEventListener('pointercancel', onUp, {passive:false});
    canvas.addEventListener('pointerdown', e=>{ const p=getPoint(e); const card=hitCard(p.x,p.y); if (card) return; const pile=hitPile(p.x,p.y); if (pile && pile.type==='stock') onDeal(); }, {passive:false});

    function onDown(e){ e.preventDefault(); canvas.setPointerCapture(e.pointerId);
      const p=getPoint(e), c=hitCard(p.x,p.y); if (!c) return; const pile=c.pile; if (!pile) return;

      if (pile.type==='reserve'){ if (!c.faceUp) return; startDrag([c], p.x,p.y); return; }

      if (pile.type==='tableau'){
        if (!c.faceUp) return;
        const idx = pile.cards.indexOf(c);
        const run = buildRunFromIndex(pile, idx); // Always pick the legal sub-run from this card
        startDrag(run.length?run:[c], p.x,p.y); return;
      }
    }
    function startDrag(cards, px,py){ state.drag={cards,dx:px-cards[0].x,dy:py-cards[0].y}; updateHighlightsForDrag(cards); }
    function onMove(e){ if (!state.drag) return; const p=getPoint(e); const {dx,dy,cards}=state.drag; const ox=p.x-dx, oy=p.y-dy; const fanY=RULES.card.fanY*state.layout.scale;
      cards.forEach((m,i)=>{ const offset = (m.pile?.type==='tableau') ? i*fanY : 0; m.x=ox; m.y=oy+offset; });
    }
    function onUp(e){
      if (!state.drag) return; const p=getPoint(e); const drag=state.drag;
      const moved=Math.hypot((drag.cards[0].x+drag.dx)-p.x,(drag.cards[0].y+drag.dy)-p.y);
      const wasAceTap=(drag.cards.length===1 && drag.cards[0].r==='A' && moved<8);
      state.pileHighlights.clear();

      if (wasAceTap){ const c=drag.cards[0]; const f=foundationTargetsFor(c); if (f.length){ performMove([c], f[0]); finalizePostMove(); state.drag=null; return; } }

      const snap=bestDropTarget(drag.cards,p.x,p.y);
      if (snap){ performMove(drag.cards, snap.pile); finalizePostMove(); }
      else { snapBack(drag.cards); }
      state.drag=null;
    }

    // ======= Rules helpers =======
    function isDescendingAltColor(run){
      for (let i=0;i<run.length-1;i++){
        const a=run[i], b=run[i+1];
        if (!(a.faceUp && b.faceUp)) return false;
        if (!isAltColor(a,b)) return false;
        if (rankIndex(a.r)!==rankIndex(b.r)+1) return false;
      }
      return true;
    }
    function buildRunFromIndex(tPile, startIdx){
      const out=[];
      for (let i=startIdx;i<tPile.cards.length;i++){
        const c=tPile.cards[i]; if (!c.faceUp) { out.length=0; break; }
        if (!out.length){ out.push(c); continue; }
        const prev=out[out.length-1];
        if (isAltColor(prev,c) && rankIndex(prev.r)===rankIndex(c.r)+1) out.push(c);
        else { out.length=0; break; }
      }
      return out;
    }

    function foundationTargetsFor(card){ const targets=[]; for (const p of Object.values(state.piles)) if (p.type==='foundation' && canPlaceOnFoundation(card,p)) targets.push(p); return targets; }
    function updateHighlightsForDrag(cards){ state.pileHighlights.clear(); for (const t of legalTargetsFor(cards)) state.pileHighlights.add(pileKey(t.pile)); }
    function bestDropTarget(cards, px,py){ const targets=legalTargetsFor(cards); if (!targets.length) return null; let best=null,bestD=Infinity; for (const t of targets){ const cx=t.pile.x+(RULES.card.w*state.layout.scale)/2, cy=t.pile.y+(RULES.card.h*state.layout.scale)/2; const d=Math.hypot(px-cx,py-cy); if (d<bestD){best=t;bestD=d;} } return best; }

    function legalTargetsFor(cards){
      const srcPile=cards[0].pile, head=cards[0], out=[];
      if (srcPile.type==='reserve'){
        for (const p of Object.values(state.piles)) if (p.type==='foundation' && canPlaceOnFoundation(head,p)) out.push({pile:p});
        return out;
      }
      if (srcPile.type==='tableau'){
        if (cards.length===1){ for (const p of Object.values(state.piles)) if (p.type==='foundation' && canPlaceOnFoundation(head,p)) out.push({pile:p}); }
        for (let i=0;i<RULES.tableauColumns;i++){ const p=state.piles[`T${i}`]; if (p===srcPile) continue; if (canPlaceOnTableau(cards,p)) out.push({pile:p}); }
        return out;
      }
      return out;
    }
    function canPlaceOnFoundation(card,fPile){ if (!fPile.cards.length) return card.r==='A'; const top=fPile.cards[fPile.cards.length-1]; return card.s===top.s && rankIndex(card.r)===rankIndex(top.r)+1; }
    function canPlaceOnTableau(run,tPile){ const head=run[0]; if (!tPile.cards.length) return head.r==='K'; const top=tPile.cards[tPile.cards.length-1]; if (!top.faceUp) return false; return isAltColor(top,head) && rankIndex(top.r)===rankIndex(head.r)+1; }

    // ======= Positioning & animation =======
    function animateTo(cards, dstPile, baseIndex, ms=200, cb){
      const start=performance.now();
      const from=cards.map(c=>({x:c.x,y:c.y}));
      const step=now=>{
        const t=Math.min(1,(now-start)/ms);
        cards.forEach((c,i)=>{
          const off = (dstPile.type==='tableau') ? i*(RULES.card.fanY*state.layout.scale) : 0;
          const tx=dstPile.x, ty=dstPile.y + off;
          c.x = from[i].x + (tx-from[i].x)*t;
          c.y = from[i].y + (ty-from[i].y)*t;
        });
        if (t<1) requestAnimationFrame(step); else cb&&cb();
      };
      requestAnimationFrame(step);
    }
    function snapBack(cards){ const p=cards[0].pile; if (!p) return; const base=p.cards.indexOf(cards[0]); animateTo(cards,p,base,160); }

    // ======= Piles & initial deal =======
    function layoutPiles(){
      state.piles={}; state.panels={};
      const s=state.layout.scale, {w,h}=RULES.card, pad=16, left=RULES.feltInsets.x, top=RULES.feltInsets.y+48;
      const W = canvas.clientWidth;

      // Foundations grid (right)
      const fCols=4, totalFW = fCols*(w*s) + (fCols-1)*pad;
      const rightStart = Math.max(left+420, W-totalFW-left);
      const fY1=top, fY2=top + h*s + 16;
      for (let i=0;i<8;i++){
        const row=(i<4)?0:1, col=(i%4), fx=rightStart + col*(w*s+pad), fy=row?fY2:fY1;
        state.piles[`F${i}`]={type:'foundation',x:fx,y:fy,cards:[]};
      }
      state.panels.right = { x:rightStart-12, y:fY1-12, w:totalFW+24, h:(h*s)*2+16+24 };

      // Stock (left) + 6 reserve cells to its right
      const stockX=left, rY=fY1;
      state.piles['STOCK']={type:'stock',x:stockX,y:rY,cards:[]};
      const rStartX = stockX + (w*s + pad)*1.2;
      for (let i=0;i<RULES.reserves;i++){
        state.piles[`R${i}`]={type:'reserve',x:rStartX + i*(RULES.reserveGap*s), y:rY, cards:[]};
      }
      const leftPanelW = (w*s) + pad + (RULES.reserveGap*s)*(RULES.reserves-1) + (w*s) + 24;
      state.panels.left = { x:stockX-12, y:rY-12, w:leftPanelW, h:(h*s)+24 };

      // Tableau row
      const tY = fY2 + h*s + 44;
      let x=left;
      for (let i=0;i<RULES.tableauColumns;i++){ state.piles[`T${i}`]={type:'tableau',x,y:tY,cards:[]}; x += (w*s + pad); }
    }

    function newGame(){
      document.getElementById('status').textContent = RULES.name;
      state.won=false; state.lost=false; hideWin(); hideLose(); state.undo=[];
      state.cards = shuffle(makeDeck(RULES.decks));
      layoutPiles();
      const stock=state.piles['STOCK']; const {fanY}=RULES.card, s=state.layout.scale;
      state.cards.forEach((c,i)=>{ c.faceUp=false; c.pile=stock; c.z=i; c.x=stock.x; c.y=stock.y + Math.min(i,4)*(fanY*s*0.15); stock.cards.push(c); });
      dealDevilsSix();
      dealTableauInitial();
      checkAutoAces();
    }

    function dealFromStockToPile(dst, faceUp=true, recordUndo=false){
      const stock=state.piles['STOCK']; if (!stock.cards.length) return null;
      const c=stock.cards.pop(); c.pile=dst; c.faceUp=!!faceUp; c.x=stock.x; c.y=stock.y; dst.cards.push(c);
      const baseIndex=dst.cards.length-1; animateTo([c], dst, baseIndex, 200);
      if (recordUndo) state.undo.push({type:'dealOne', dstKey:pileKey(dst), cardId:c.id});
      return c;
    }

    function dealDevilsSix(){ for (let i=0;i<RULES.reserves;i++) dealFromStockToPile(state.piles[`R${i}`], true); }

    function dealTableauInitial(){
      const pattern=[0,1,2,3,4,4,3,2,1,0];
      for (let i=0;i<10;i++){
        const t=state.piles[`T${i}`]; const downs=pattern[i];
        for (let d=0; d<downs; d++) dealFromStockToPile(t,false);
        dealFromStockToPile(t,true);
      }
    }

    function onDeal(){
      const stock=state.piles['STOCK']; if (!stock.cards.length) return;
      const batch=[];
      for (let i=0;i<RULES.tableauColumns;i++){
        const t=state.piles[`T${i}`];
        const top=t.cards[t.cards.length-1];
        const skip = top && top.faceUp && top.r==='K'; // Strict per REQ-STATE-2.3.6
        if (skip) continue;
        const dealt=dealFromStockToPile(t,true,true); if (dealt) batch.push({dstKey:pileKey(t), cardId:dealt.id});
      }
      if (batch.length) state.undo.push({type:'dealBatch', items:batch});
      finalizePostMove();
    }

    // ======= Moves / undo / end-states =======
    function performMove(cards, dstPile, recordUndo=true){
      const srcPile=cards[0].pile; const srcKey=pileKey(srcPile), dstKey=pileKey(dstPile);
      const startIdx=srcPile.cards.indexOf(cards[0]);
      srcPile.cards.splice(startIdx, cards.length);
      for (const c of cards){ c.pile=dstPile; dstPile.cards.push(c); }
      const baseIndex=dstPile.cards.length - cards.length; animateTo(cards, dstPile, baseIndex, 160);
      const reveal=srcPile.cards[srcPile.cards.length-1]; let flippedId=null;
      if (reveal && !reveal.faceUp && srcPile.type==='tableau'){ reveal.faceUp=true; flippedId=reveal.id; }
      if (recordUndo) state.undo.push({type:'move', cardIds:cards.map(c=>c.id), srcKey, dstKey, dstCount:cards.length, flippedId});
    }

    function canPlaceOnFoundation(card,fPile){ if (fPile.type!=='foundation') return false; if (!fPile.cards.length) return card.r==='A'; const top=fPile.cards[fPile.cards.length-1]; return card.s===top.s && rankIndex(card.r)===rankIndex(top.r)+1; }
    function canPlaceOnTableau(run,tPile){ if (tPile.type!=='tableau') return false; const head=run[0]; if (!tPile.cards.length) return head.r==='K'; const top=tPile.cards[tPile.cards.length-1]; if (!top.faceUp) return false; return isAltColor(top,head) && rankIndex(top.r)===rankIndex(head.r)+1; }

    function foundationAutoFrom(list){
      const empties = Object.values(state.piles).filter(p=>p.type==='foundation' && !p.cards.length);
      if (!empties.length) return false;
      for (const c of list){ if (c && c.r==='A'){ performMove([c], empties[0]); return true; } }
      return false;
    }

    function checkAutoAces(){
      let moved=true;
      while(moved){
        moved=false;
        const tops=[];
        for (let i=0;i<RULES.tableauColumns;i++){ const t=state.piles[`T${i}`]; const top=t.cards[t.cards.length-1]; if (top && top.faceUp) tops.push(top); }
        for (let i=0;i<RULES.reserves;i++){ const rTop = state.piles[`R${i}`].cards[0]; if (rTop) tops.push(rTop); }
        if (foundationAutoFrom(tops)) moved=true;
      }
      checkWin();
    }

    function undoLast(){
      const step=state.undo.pop(); if (!step) return;
      switch(step.type){
        case 'move': {
          const dst=state.piles[step.dstKey], src=state.piles[step.srcKey];
          const moving=dst.cards.splice(dst.cards.length - step.dstCount, step.dstCount);
          moving.forEach(c=>{ c.pile=src; src.cards.push(c); });
          if (step.flippedId){ const f=state.cards.find(c=>c.id===step.flippedId); if (f) f.faceUp=false; }
          break;
        }
        case 'dealOne': {
          const dst=state.piles[step.dstKey]; if (dst.cards.length){
            const c=dst.cards.pop(); c.pile=state.piles['STOCK']; c.faceUp=false; state.piles['STOCK'].cards.push(c);
          }
          break;
        }
        case 'dealBatch': {
          for (let i=step.items.length-1;i>=0;i--){
            const it=step.items[i]; const dst=state.piles[it.dstKey];
            if (dst.cards.length){
              const c=dst.cards.pop(); c.pile=state.piles['STOCK']; c.faceUp=false; state.piles['STOCK'].cards.push(c);
            }
          }
          break;
        }
      }
      render();
    }

    function hasAnyValidMove(){
      // tableau â†’ foundation / tableau
      for (let i=0;i<RULES.tableauColumns;i++){
        const t=state.piles[`T${i}`];
        // single to foundation
        const top=t.cards[t.cards.length-1]; if (top && top.faceUp){ for (const f of Object.values(state.piles)) if (f.type==='foundation' && canPlaceOnFoundation(top,f)) return true; }
        // sub-runs to tableau
        for (let j=0;j<t.cards.length;j++){
          const run=t.cards.slice(j); if (!run.length || !run[0].faceUp) continue; if (!isDescendingAltColor(run)) continue;
          for (let k=0;k<RULES.tableauColumns;k++) if (k!==i){ const dest=state.piles[`T${k}`]; if (canPlaceOnTableau(run,dest)) return true; }
        }
      }
      // any reserve card to foundation
      for (let i=0;i<RULES.reserves;i++){
        const c = state.piles[`R${i}`].cards[0];
        if (c) for (const f of Object.values(state.piles)) if (f.type==='foundation' && canPlaceOnFoundation(c,f)) return true;
      }
      return false;
    }

    function checkWin(){ const total=Object.values(state.piles).filter(p=>p.type==='foundation').reduce((a,p)=>a+p.cards.length,0); if (total===104 && !state.won){ state.won=true; showWin(); } }
    function checkLose(){ if (state.won) return false; const stock=state.piles['STOCK']; if (stock.cards.length>0) return false; if (hasAnyValidMove()) return false; state.lost=true; showLose(); return true; }
    function finalizePostMove(){ checkAutoAces(); checkWin(); checkLose(); }

    // ======= UI wiring =======
    document.getElementById('btnNew').addEventListener('click', ()=>{ resize(); newGame(); });
    document.getElementById('btnDeal').addEventListener('click', ()=>{ try{ onDeal(); }catch(e){ console.error('Deal error:',e); } });
    document.getElementById('btnUndo').addEventListener('click', undoLast);
    document.getElementById('btnPlayAgain').addEventListener('click', ()=>{ hideWin(); resize(); newGame(); });
    document.getElementById('btnRetry').addEventListener('click', ()=>{ hideLose(); resize(); newGame(); });
    document.getElementById('cbPortrait').addEventListener('change', ()=>{ resize(); render(); });
    window.addEventListener('resize', ()=>resize());
    window.addEventListener('orientationchange', ()=>setTimeout(resize,200));

    function showWin(){ document.getElementById('winModal').classList.remove('hidden'); }
    function hideWin(){ document.getElementById('winModal').classList.add('hidden'); }
    function showLose(){ document.getElementById('loseModal').classList.remove('hidden'); }
    function hideLose(){ document.getElementById('loseModal').classList.add('hidden'); }

    function tick(){ render(); requestAnimationFrame(tick); }

    // ======= Self-tests =======
    function runSelfTests(){
      // Devil's Six has 6 cards (one per reserve cell)
      let rCount=0; for (let i=0;i<RULES.reserves;i++) rCount += state.piles[`R${i}`].cards.length;
      console.assert(rCount===6, 'Devil\'s Six should have 6 cards (one per cell)');

      // Tableau initial: 30 cards total (20 down, 10 up)
      const pattern=[0,1,2,3,4,4,3,2,1,0];
      let tableauTotal=0, ups=0, downs=0;
      for (let i=0;i<10;i++){
        const t=state.piles[`T${i}`]; tableauTotal += t.cards.length; downs += pattern[i];
        const top=t.cards[t.cards.length-1]; if (top && top.faceUp) ups++;
      }
      console.assert(tableauTotal===30,'Tableau should contain 30 cards');
      console.assert(ups===10,'Each tableau column should end with 1 face-up');
      console.assert(downs===20,'There should be 20 face-down cards in tableau');

      // Run building sanity
      const synth={cards:[{r:'10',s:'â™ ',faceUp:true},{r:'9',s:'â™¥',faceUp:true},{r:'8',s:'â™ ',faceUp:true},{r:'7',s:'â™¥',faceUp:true}]};
      let run=buildRunFromIndex(synth,0); console.assert(run.length===4,'buildRunFromIndex should return 10-9-8-7');
      run=buildRunFromIndex(synth,2); console.assert(run.length===2 && run[0].r==='8','buildRunFromIndex should pick 8-7 from middle');
    }

    // ======= Boot =======
    resize(); newGame(); runSelfTests(); requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
