<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Churchill Solitaire — Devil's Six</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }
    body {
      font-family: "Avenir Next", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #f4ede0;
      background: radial-gradient(circle at top, rgba(97, 54, 23, 0.6) 0%, rgba(26, 14, 6, 0.92) 60%),
        radial-gradient(circle at bottom, rgba(22, 12, 6, 0.92) 0%, rgba(14, 7, 3, 0.98) 62%);
      background-attachment: fixed;
      overflow-y: auto;
      overflow-x: auto;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding-top: 12px;
      box-sizing: border-box;
    }
    #app {
      width: min(1220px, 100%);
      padding: 0 20px 24px;
      box-sizing: border-box;
    }
    #hud {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 18px;
      padding: 12px 24px;
      background: linear-gradient(180deg, rgba(35, 22, 13, 0.88) 0%, rgba(22, 12, 6, 0.92) 100%);
      border: 1px solid rgba(255, 222, 166, 0.32);
      border-radius: 18px;
      box-shadow: 0 18px 38px rgba(0, 0, 0, 0.4);
      margin: 0 auto 4px;
      backdrop-filter: blur(2px);
      width: min(520px, 100%);
      align-self: center;
      pointer-events: auto;
      z-index: 0;
      flex-wrap: wrap;
    }
    #identity {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #f7e7c4;
      min-width: 140px;
    }
    #identity .title {
      font-size: 16px;
      letter-spacing: 0.18em;
    }
    #identity .subtitle {
      font-size: 10px;
      color: rgba(247, 231, 196, 0.72);
      letter-spacing: 0.26em;
    }
    #hudButtons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .btn {
      background: linear-gradient(180deg, rgba(71, 48, 24, 0.95) 0%, rgba(38, 23, 12, 0.95) 90%);
      border: none;
      border-radius: 999px;
      color: #f9e1a7;
      padding: 10px 18px;
      font-weight: 700;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }
    .btn:focus {
      outline: none;
    }
    .btn:focus-visible {
      outline: none;
      box-shadow: 0 14px 26px rgba(0, 0, 0, 0.45);
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(0, 0, 0, 0.45);
      background: linear-gradient(180deg, rgba(92, 63, 30, 0.98) 0%, rgba(48, 29, 14, 0.98) 90%);
    }
    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    #boardArea {
      position: relative;
      background: radial-gradient(circle at center, rgba(19, 10, 4, 0.86), rgba(13, 7, 3, 0.94));
      border-radius: 24px;
      padding: 30px 22px 30px;
      box-shadow: inset 0 0 28px rgba(0, 0, 0, 0.55), 0 24px 50px rgba(0, 0, 0, 0.55);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 18px;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    #message {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    #messageContent {
      pointer-events: auto;
      background: rgba(17, 10, 4, 0.94);
      padding: 32px 40px;
      border: 1px solid rgba(244, 215, 140, 0.8);
      border-radius: 18px;
      box-shadow: 0 22px 36px rgba(0, 0, 0, 0.6);
      text-align: center;
      min-width: 280px;
    }
    #messageText {
      margin-bottom: 16px;
      font-size: 20px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #ffecc4;
    }
    @media (max-width: 780px) {
      #boardArea {
        padding: 18px 16px 28px;
        gap: 14px;
      }
      #hud {
        margin: 6px auto 0;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        max-width: none;
      }
      #identity {
        align-items: center;
        text-align: center;
      }
      #hudButtons {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <main id="boardArea">
      <header id="hud">
        <div id="identity">
          <div class="title">Devil's Six</div>
          <div class="subtitle" id="version"></div>
        </div>
        <div id="hudButtons">
          <button id="newGame" class="btn">New Deal</button>
          <button id="undo" class="btn">Undo</button>
        </div>
      </header>
      <canvas id="game"></canvas>
      <div id="message">
        <div id="messageContent">
          <div id="messageText"></div>
          <button id="playAgain" class="btn">Play Again</button>
        </div>
      </div>
    </main>
  </div>

  <script>
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const VERSION = '2.9';
  document.getElementById('version').textContent = `Version ${VERSION}`;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
  const COLORS = { '\u2660':'black', '\u2663':'black', '\u2665':'red', '\u2666':'red' };
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL  = { A:1, J:11, Q:12, K:13 };
  for (let i=2;i<=10;i++) RVAL[i]=i;
  const PADDING = 16;

  class Card {
    constructor(suit, rank){
      this.suit = suit;
      this.rank = rank;
      this.value = RVAL[rank];
      this.color = COLORS[suit];
      this.faceUp = false;
    }
  }

  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]);
  let stock = [];
  let deck = [];
  let deals = 0;
  let undoStack = [];
  let isAnimatingDeal = false;

  // ★ NEW: track which tableau columns have had a king planted
  let anchoredCols = new Array(10).fill(false);

  let CARD_W = 80, CARD_H = 120, OVERLAP = 22;
  let tableauGap = 10;
  let boardWidth = 0;
  let boardHeight = 0;

  const TopGeom = {
    dsX: PADDING,
    dsY: PADDING,
    dsStep: 26,
    stockX: 0,
    stockY: 0,
    fSlots: [],
    fCols: 4,
    fRows: 2,
    fGapX: 10,
    fGapY: 8,
    fY: PADDING
  };

  function layout(w){
    const inner = Math.max(320, w - PADDING * 2);
    const maxCard = Math.min(126, Math.floor(inner / 10));
    let desired = Math.floor(inner / 10.6);
    desired = Math.min(desired + 4, maxCard);
    let card = Math.max(60, desired);
    let gap = Math.max(8, Math.floor(card * 0.14));
    let total = card * 10 + gap * 9;
    if (total > inner){
      const scale = inner / total;
      card = Math.max(56, Math.floor(card * scale));
      gap = Math.max(5, Math.floor(gap * scale));
      total = card * 10 + gap * 9;
    }
    while (total > inner && card > 56){
      card--;
      gap = Math.max(5, Math.floor(card * 0.14));
      total = card * 10 + gap * 9;
    }
    const grown = card + 2;
    const grownGap = Math.max(5, Math.floor(grown * 0.14));
    if (grown * 10 + grownGap * 9 <= inner){
      card = grown;
      gap = grownGap;
    }
    tableauGap = Math.max(5, Math.min(24, gap));
    CARD_W = Math.max(56, Math.min(126, card));
    CARD_H = Math.max(94, Math.floor(CARD_W * 1.45) - 2);
    OVERLAP = Math.max(20, Math.floor(CARD_H * 0.23));
  }
  function tableauGutter(){
    return tableauGap;
  }
  function colX(c){ return PADDING + c * (CARD_W + tableauGutter()); }
  function tableauCardPos(col, row){
    return { x: colX(col), y: tableauTopY() + row * OVERLAP };
  }
  function devilsCardPos(idx){
    return { x: TopGeom.dsX + idx * TopGeom.dsStep, y: TopGeom.dsY };
  }
  function shouldAnchorColumn(col){
    if (!col.length) return false;
    for (let i=0;i<col.length;i++) if (!col[i].faceUp) return false;
    const base = col[0];
    return base && base.faceUp && base.value === 13;
  }
  function refreshAnchorForColumn(idx){
    anchoredCols[idx] = shouldAnchorColumn(tableau[idx]);
  }
  function refreshAllAnchors(){
    for (let i=0;i<tableau.length;i++) refreshAnchorForColumn(i);
  }
  function tableauTopY(){
    const top = TopGeom.fY + (CARD_H * TopGeom.fRows) + (TopGeom.fGapY * (TopGeom.fRows - 1)) + Math.max(4, Math.floor(CARD_H * 0.05));
    return Math.max(top, CARD_H + Math.max(16, Math.floor(CARD_H * 0.14)));
  }
  function computeTopGeometry(){
    const topBand = Math.max(3, Math.floor(CARD_H * 0.032));
    TopGeom.dsY = topBand;
    TopGeom.dsStep = Math.max(Math.floor(CARD_W * 0.32), 22);
    TopGeom.fGapX = Math.max(Math.floor(CARD_W * 0.18), 12);
    TopGeom.fGapY = Math.max(Math.floor(CARD_H * 0.055), 6);
    TopGeom.stockX = PADDING;
    TopGeom.stockY = TopGeom.dsY;
    TopGeom.fY = Math.max(4, topBand + Math.max(Math.floor(CARD_H * 0.015), 2));
    const dsSlots = Math.max(devilsSix.length, 6);
    const dsWidth = CARD_W + TopGeom.dsStep * (dsSlots - 1);
    TopGeom.dsX = TopGeom.stockX + CARD_W + Math.max(28, Math.floor(CARD_W * 0.6));

    const totalFW = TopGeom.fCols * CARD_W + (TopGeom.fCols - 1) * TopGeom.fGapX;
    const minStart = TopGeom.dsX + dsWidth + Math.max(30, Math.floor(CARD_W * 0.7));
    let startX = boardWidth - PADDING - totalFW;
    if (startX < minStart){
      startX = Math.max(PADDING, Math.min(minStart, boardWidth - PADDING - totalFW));
    }
    startX = Math.max(PADDING, startX);
    TopGeom.fSlots = [];
    for (let row=0; row<TopGeom.fRows; row++){
      for (let col=0; col<TopGeom.fCols; col++){
        const x = startX + col*(CARD_W + TopGeom.fGapX);
        const y = TopGeom.fY + row*(CARD_H + TopGeom.fGapY);
        TopGeom.fSlots.push({x,y});
      }
    }
  }
  function computeBoardHeight(){
    const tTop = tableauTopY();
    let tallest = 1;
    for (let i=0;i<tableau.length;i++){
      tallest = Math.max(tallest, tableau[i].length);
    }
    return Math.max(window.innerHeight * 0.82, tTop + (tallest - 1) * OVERLAP + CARD_H + PADDING);
  }
  function syncBoardMetrics(){
    const width = canvas.clientWidth || canvas.parentElement.clientWidth || window.innerWidth;
    boardWidth = width;
    layout(width);
    computeTopGeometry();
    const desiredHeight = computeBoardHeight();
    if (Math.abs(desiredHeight - boardHeight) > 1){
      boardHeight = desiredHeight;
      canvas.style.height = `${boardHeight}px`;
    }
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(boardHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  function positionHud(){
    if (!hud) return;
    const computed = window.getComputedStyle(hud);
    if (computed.position !== 'absolute'){
      hud.style.transform = 'none';
      hud.style.left = '';
      hud.style.top = '';
      return;
    }
    const hudWidth = hud.offsetWidth || 0;
    const hudHeight = hud.offsetHeight || 0;
    const dsSlots = Math.max(devilsSix.length, 6);
    const dsRight = TopGeom.dsX + CARD_W + TopGeom.dsStep * (dsSlots - 1);
    const stockRight = TopGeom.stockX + CARD_W;
    let foundationLeft = boardWidth - PADDING - CARD_W;
    if (TopGeom.fSlots.length){
      foundationLeft = TopGeom.fSlots[0].x;
    }
    const margin = Math.max(12, Math.floor(CARD_W * 0.22));
    const gap = foundationLeft - dsRight;
    let targetX;
    if (gap >= hudWidth + margin * 2){
      targetX = dsRight + (gap - hudWidth) / 2;
    } else {
      targetX = Math.max(stockRight + margin, dsRight + margin) - hudWidth / 2;
    }
    const fallbackRight = Math.max(PADDING, boardWidth - PADDING - hudWidth);
    let rightLimit = fallbackRight;
    if (TopGeom.fSlots.length){
      rightLimit = Math.min(rightLimit, foundationLeft - margin - hudWidth);
    }
    if (rightLimit < PADDING) rightLimit = fallbackRight;
    const clampedLeft = Math.max(PADDING, Math.min(targetX, rightLimit));
    hud.style.left = `${clampedLeft}px`;

    const minTop = TopGeom.dsY + Math.max(4, Math.floor(CARD_H * 0.06));
    const maxTop = TopGeom.fY + CARD_H - hudHeight - Math.max(4, Math.floor(CARD_H * 0.08));
    const mid = TopGeom.dsY + CARD_H / 2 - hudHeight / 2;
    let top = mid;
    if (maxTop < minTop){
      top = minTop;
    } else {
      top = Math.max(minTop, Math.min(mid, maxTop));
    }
    hud.style.top = `${Math.max(TopGeom.dsY, top)}px`;
    hud.style.transform = 'none';
  }
  function render(){
    syncBoardMetrics();
    draw();
  }
  function resizeCanvas(){
    render();
  }
  window.addEventListener('resize', resizeCanvas);

  let stockHit = {x:0,y:0,w:0,h:0};
  let drag = null;
  let mouseX = 0, mouseY = 0;

  function drawRoundRect(x,y,w,h,r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawCard(card,x,y,opts={}){
    const {highlight=false,empty=false,suitHint=null,ghost=false} = opts;
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = ghost ? 0.85 : 1;
    const radius = Math.max(6, CARD_W * 0.1);
    if (card){
      ctx.shadowColor = 'rgba(0,0,0,0.42)';
      ctx.shadowBlur = Math.max(12, CARD_W * 0.25);
      ctx.shadowOffsetY = Math.max(4, CARD_H * 0.08);
      const shellGradient = ctx.createLinearGradient(0,0,0,CARD_H);
      if (card.faceUp){
        shellGradient.addColorStop(0, '#faf8f4');
        shellGradient.addColorStop(0.55, '#ffffff');
        shellGradient.addColorStop(1, '#e9e3d7');
      } else {
        shellGradient.addColorStop(0, '#204a92');
        shellGradient.addColorStop(1, '#112a62');
      }
      ctx.fillStyle = shellGradient;
      drawRoundRect(0,0,CARD_W,CARD_H,radius);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      drawRoundRect(0,0,CARD_W,CARD_H,radius);
      ctx.lineWidth = card.faceUp ? 1.4 : 1.8;
      ctx.strokeStyle = card.faceUp ? '#1a1a1a' : '#0a163a';
      ctx.stroke();

      if (card.faceUp){
        const insetRadius = Math.max(5, CARD_W * 0.1);
        drawRoundRect(6,6,CARD_W-12,CARD_H-12,insetRadius);
        const faceGradient = ctx.createLinearGradient(6,6,CARD_W-6,CARD_H-6);
        faceGradient.addColorStop(0, 'rgba(255,255,255,0.92)');
        faceGradient.addColorStop(1, 'rgba(233,229,216,0.88)');
        ctx.fillStyle = faceGradient;
        ctx.fill();

        const cornerInsetX = Math.floor(CARD_W * 0.075);
        const cornerInsetY = Math.floor(CARD_H * 0.036);
        const rightInsetX = CARD_W - cornerInsetX;
        ctx.fillStyle = card.color === 'red' ? '#be1e2d' : '#141414';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.font = `700 ${Math.floor(CARD_W/3.55)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.rank, cornerInsetX, cornerInsetY);

        ctx.textAlign = 'right';
        ctx.font = `${Math.floor(CARD_W/4.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.suit, rightInsetX, cornerInsetY + Math.floor(CARD_H * 0.006));

        ctx.save();
        ctx.translate(CARD_W, CARD_H);
        ctx.rotate(Math.PI);
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.font = `700 ${Math.floor(CARD_W/3.55)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.rank, cornerInsetX, cornerInsetY);
        ctx.textAlign = 'right';
        ctx.font = `${Math.floor(CARD_W/4.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.fillText(card.suit, CARD_W - cornerInsetX, cornerInsetY + Math.floor(CARD_H * 0.006));
        ctx.restore();

        ctx.save();
        ctx.translate(CARD_W/2, CARD_H/2);
        ctx.font = `600 ${Math.floor(CARD_W/2.05)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.16;
        ctx.fillStyle = card.color === 'red' ? '#c23c3c' : '#262626';
        ctx.fillText(card.suit, 0, 0);
        ctx.restore();
      } else {
        const insetRadius = Math.max(5, CARD_W * 0.1);
        drawRoundRect(6,6,CARD_W-12,CARD_H-12,insetRadius);
        ctx.save();
        ctx.clip();
        const primary = ctx.createLinearGradient(0,0,CARD_W,CARD_H);
        primary.addColorStop(0, '#1b3e82');
        primary.addColorStop(1, '#102a5a');
        ctx.fillStyle = primary;
        ctx.fillRect(0,0,CARD_W,CARD_H);

        const sheen = ctx.createRadialGradient(CARD_W*0.3, CARD_H*0.25, CARD_W*0.1, CARD_W*0.3, CARD_H*0.25, CARD_W);
        sheen.addColorStop(0, 'rgba(255,255,255,0.28)');
        sheen.addColorStop(0.45, 'rgba(255,255,255,0.12)');
        sheen.addColorStop(1, 'rgba(16,42,90,0.05)');
        ctx.fillStyle = sheen;
        ctx.fillRect(0,0,CARD_W,CARD_H);

        const emblem = ctx.createRadialGradient(CARD_W/2, CARD_H/2, CARD_W*0.1, CARD_W/2, CARD_H/2, CARD_W*0.52);
        emblem.addColorStop(0, 'rgba(8,18,48,0.45)');
        emblem.addColorStop(1, 'rgba(8,18,48,0)');
        ctx.fillStyle = emblem;
        ctx.fillRect(0,0,CARD_W,CARD_H);
        ctx.restore();
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = 'rgba(255,255,255,0.32)';
        ctx.stroke();
      }

      if (highlight){
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffd86b';
        drawRoundRect(1.5,1.5,CARD_W-3,CARD_H-3, Math.max(6, radius-2));
        ctx.stroke();
      }
    } else {
      ctx.setLineDash([7,7]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(237, 202, 120, 0.8)';
      drawRoundRect(0.5,0.5,CARD_W-1,CARD_H-1,radius);
      ctx.stroke();
      ctx.setLineDash([]);
      if (suitHint){
        ctx.fillStyle = 'rgba(255,255,255,0.22)';
        ctx.font = `700 ${Math.floor(CARD_W/3.2)}px "Avenir Next", "Segoe UI", sans-serif`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('A'+suitHint, CARD_W/2, CARD_H/2);
      }
    }
    ctx.restore();
  }

  function draw(){
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    const dsSlots = Math.max(devilsSix.length, 6);
    for (let i=0;i<dsSlots;i++){
      const isDraggingDevil = drag && drag.from.type === 'devils' && drag.from.idx === i;
      const card = (!isDraggingDevil && devilsSix[i]) ? devilsSix[i] : null;
      drawCard(card, TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY, {empty:!card});
    }
    drawCard(stock.length ? {faceUp:false} : null, TopGeom.stockX, TopGeom.stockY);
    stockHit = {x:TopGeom.stockX, y:TopGeom.stockY, w:CARD_W, h:CARD_H};

    for (let i=0;i<8;i++){
      const slot = TopGeom.fSlots[i];
      const stack = foundations[i];
      const top = stack.length ? stack[stack.length-1] : null;
      drawCard(top, slot.x, slot.y, {empty:!top, suitHint:SUITS[i%4]});
    }

    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const x = colX(c);
      const col = tableau[c];
      if (!col.length){
        drawCard(null,x,tY);
        continue;
      }
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
        drawCard(card, x, tY + i*OVERLAP);
      }
    }

    if (drag){
      let baseX = (drag.renderX !== undefined ? drag.renderX : mouseX - CARD_W/2);
      let baseY = (drag.renderY !== undefined ? drag.renderY : mouseY - CARD_H/2);
      if (drag.snap){
        const strength = drag.snap.strength ?? 0.7;
        baseX = baseX * (1 - strength) + drag.snap.x * strength;
        baseY = baseY * (1 - strength) + drag.snap.y * strength;
      }
      for (let i=0;i<drag.cards.length;i++){
        drawCard(drag.cards[i], baseX, baseY + i*OVERLAP, {ghost:true,highlight:true});
      }
    }
    positionHud();
  }

  let drawPending = false;
  function queueDraw(immediate=false){
    if (immediate){
      drawPending = false;
      draw();
      return;
    }
    if (drawPending) return;
    drawPending = true;
    requestAnimationFrame(()=>{
      drawPending = false;
      draw();
    });
  }

  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

  function hitAt(x,y,loose=false){
    const fMarginX = loose ? Math.max(20, Math.floor(CARD_W * 0.7)) : Math.max(0, Math.floor(CARD_W * 0.08));
    const fMarginY = loose ? Math.max(18, Math.floor(CARD_H * 0.6)) : Math.max(0, Math.floor(CARD_H * 0.08));
    const tMarginX = loose ? Math.max(24, Math.floor(CARD_W * 0.75)) : Math.max(0, Math.floor(CARD_W * 0.08));
    const tMarginY = loose ? Math.max(26, Math.floor(CARD_H * 0.62)) : Math.max(0, Math.floor(CARD_H * 0.08));

    for (let i=0;i<8;i++){
      const s = TopGeom.fSlots[i];
      if (x>s.x - fMarginX && x<s.x+CARD_W + fMarginX && y>s.y - fMarginY && y<s.y+CARD_H + fMarginY)
        return {type:'foundation', idx:i};
    }
    for (let i=0;i<devilsSix.length;i++){
      const dx = TopGeom.dsX + i*TopGeom.dsStep, dy=TopGeom.dsY;
      if (x>dx && x<dx+CARD_W && y>dy && y<dy+CARD_H)
        return {type:'devils', idx:i};
    }
    if (stock.length && x>stockHit.x && x<stockHit.x+CARD_W && y>stockHit.y && y<stockHit.y+CARD_H)
      return {type:'stock'};

    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const cx = colX(c);
      const col = tableau[c];
      if (!col.length){
        if (x>cx - tMarginX && x<cx+CARD_W + tMarginX && y>tY - tMarginY && y<tY+CARD_H + tMarginY) return {type:'tableau', col:c, row:-1};
        continue;
      }
      for (let i=col.length-1;i>=0;i--){
        const cy = tY + i*OVERLAP;
        if (x>cx - tMarginX && x<cx+CARD_W + tMarginX && y>cy - tMarginY && y<cy+CARD_H + tMarginY)
          return {type:'tableau', col:c, row:i};
      }
    }
    return null;
  }

  function getRunLength(col, start){
    const arr = tableau[col];
    let len = 1;
    for (let i=start+1;i<arr.length;i++){
      const prev = arr[i-1], cur = arr[i];
      if (!cur.faceUp) break;
      if (prev.color === cur.color) break;
      if (cur.value !== prev.value - 1) break;
      len++;
    }
    return len;
  }
  function canPlaceOnTableau(card, toCol){
    const col = tableau[toCol];
    const top = col[col.length-1];
    if (!top) return card.value === 13;
    return (card.color !== top.color) && (card.value === top.value - 1);
  }
  function canPlaceOnFoundation(card, fIdx){
    if (SUITS[fIdx % 4] !== card.suit) return false;
    const stack = foundations[fIdx];
    const top   = stack[stack.length-1];
    return top ? (card.value === top.value + 1) : (card.value === 1);
  }
  function findFoundationTarget(card){
    const matches = [];
    for (let f=0; f<8; f++) if (SUITS[f % 4] === card.suit) matches.push(f);
    if (!matches.length) return null;
    if (card.value === 1){
      for (const f of matches){
        if (foundations[f].length === 0) return f;
      }
    }
    for (const f of matches){
      if (canPlaceOnFoundation(card, f)) return f;
    }
    return null;
  }
  function commitCardToFoundation(card, from){
    const target = findFoundationTarget(card);
    if (target === null) return false;
    const snapshot = JSON.parse(JSON.stringify(from));
    if (from.type === 'tableau'){
      const colArr = tableau[from.col];
      if (!colArr.length) return false;
      const topIdx = colArr.length - 1;
      if (topIdx !== from.idx || colArr[topIdx] !== card) return false;
      foundations[target].push(card);
      colArr.pop();
      flipTop(from.col);
    } else if (from.type === 'devils'){
      if (devilsSix[from.idx] !== card) return false;
      foundations[target].push(card);
      devilsSix.splice(from.idx, 1);
    } else {
      return false;
    }
    undoStack.push({kind:'toFound', from:snapshot, fIdx:target, card});
    render();
    updateUI();
    checkWinOrStuck();
    return true;
  }
  function attemptAutoFoundationAt(x, y){
    if (isAnimatingDeal) return false;
    const hit = hitAt(x, y, true);
    if (!hit) return false;
    if (hit.type === 'tableau'){
      const colArr = tableau[hit.col];
      if (!colArr.length) return false;
      const topIdx = colArr.length - 1;
      const card = colArr[topIdx];
      if (!card || !card.faceUp) return false;
      return commitCardToFoundation(card, {type:'tableau', col:hit.col, idx:topIdx});
    }
    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      if (!card) return false;
      return commitCardToFoundation(card, {type:'devils', idx:hit.idx});
    }
    return false;
  }
  function flipTop(col){
    const colArr = tableau[col];
    if (colArr.length && !colArr[colArr.length-1].faceUp)
      colArr[colArr.length-1].faceUp = true;
    refreshAnchorForColumn(col);
  }
  function canStartDragAt(col, row){
    const colArr = tableau[col];
    if (row < 0 || row >= colArr.length) return false;
    const card = colArr[row];
    if (!card.faceUp) return false;
    return true;
  }

  // ===== DEAL =====
  async function doDeal(){
    if (isAnimatingDeal) return;
    if (!stock.length) {
      render();
      updateUI();
      return;
    }

    refreshAllAnchors();

    // if ALL columns are anchored-by-king, don't deal
    let allAnchored = true;
    for (let c=0;c<10;c++){
      if (!anchoredCols[c]) {
        allAnchored = false;
        break;
      }
    }
    if (allAnchored) {
      render();
      updateUI();
      return;
    }

    const dealt = [];
    for (let c=0;c<10;c++){
      if (!stock.length) break;
      if (anchoredCols[c]) continue;

      const card = stock.pop();
      if (!card) break;
      card.faceUp = true;
      dealt.push({col:c, card});
    }

    if (!dealt.length){
      render();
      updateUI();
      return;
    }

    deals++;
    undoStack.push({kind:'deal', payload:dealt.map(step=>({col:step.col, card:step.card}))});
    isAnimatingDeal = true;
    const newDealBtn = document.getElementById('newGame');
    if (newDealBtn) newDealBtn.disabled = true;
    updateUI(true);

    const stepDelay = Math.max(45, Math.min(120, Math.floor(1200 / dealt.length)));
    try {
      for (let i=0;i<dealt.length;i++){
        const step = dealt[i];
        tableau[step.col].push(step.card);
        refreshAnchorForColumn(step.col);
        render();
        if (i < dealt.length - 1) await sleep(stepDelay);
      }
    } finally {
      isAnimatingDeal = false;
      if (newDealBtn) newDealBtn.disabled = false;
    }

    render();
    updateUI();
    checkWinOrStuck();
  }

  function hasAnyMoves(){
    for (let c=0;c<10;c++){
      const top = tableau[c][tableau[c].length-1];
      if (!top) continue;
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(top,f)) return true;
    }
    for (const card of devilsSix){
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(card,f)) return true;
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      const start = col.findIndex(c=>c.faceUp);
      if (start<0) continue;
      for (let i=start;i<col.length;i++){
        const base = col[i];
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(base,to)) return true;
        }
      }
    }
    return false;
  }
  function checkWinOrStuck(){
    const total = foundations.reduce((n,s)=>n+s.length,0);
    if (total === 104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      finishGame(true);
      return;
    }
    if (!stock.length && !hasAnyMoves()){
      finishGame(false);
    }
  }
  function finishGame(win){
    if (win){
      showMessage('Victory! Foundations complete.');
    } else {
      showMessage('No more moves.');
    }
  }

  function buildDeck(){
    const temp = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          temp.push(new Card(s,r));
        }
      }
    }
    for (let i=temp.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [temp[i], temp[j]] = [temp[j], temp[i]];
    }
    deck = temp;
  }
  function drawDevilsSixFromDeck(){
    const cards = [];
    for (let i=0;i<6;i++){
      const c = deck.pop();
      c.faceUp = true;
      cards.push(c);
    }
    return cards;
  }

  function isDevilsSixUnwinnable(cards){
    const suitRuns = {};
    for (let i=cards.length-1;i>=0;i--){
      const card = cards[i];
      if (!suitRuns[card.suit]) suitRuns[card.suit] = [];
      suitRuns[card.suit].push(card.value);
    }
    for (const values of Object.values(suitRuns)){
      if (values.length < 3) continue;
      const extended = values.slice();
      let aceCopies = values.filter(v=>v===1).length;
      while (aceCopies-- > 0) extended.push(14);
      extended.sort((a,b)=>b-a);
      let run = 1;
      let prev = extended[0];
      for (let i=1;i<extended.length;i++){
        const cur = extended[i];
        if (cur === prev) continue;
        if (cur === prev - 1){
          run++;
          if (run >= 3) return true;
        } else {
          run = 1;
        }
        prev = cur;
      }
    }
    return false;
  }

  function preparePlayableDevilsSix(){
    const MAX_ATTEMPTS = 5000;
    let attempt = 0;
    let candidate = [];
    while (attempt < MAX_ATTEMPTS){
      buildDeck();
      candidate = drawDevilsSixFromDeck();
      if (!isDevilsSixUnwinnable(candidate)){
        return candidate;
      }
      attempt++;
    }
    console.warn('Unable to find a guaranteed winnable Devil\'s Six after many attempts; proceeding with current deal.');
    return candidate;
  }

  function newGame(){
    undoStack = [];
    anchoredCols = new Array(10).fill(false);
    foundations = new Array(8).fill(0).map(()=>[]);
    tableau = new Array(10).fill(0).map(()=>[]);
    stock = [];

    const freshDevilsSix = preparePlayableDevilsSix();
    devilsSix = freshDevilsSix;

    const downs = [0,1,2,3,4,4,3,2,1,0];
    for (let col=0; col<10; col++){
      for (let d=0; d<downs[col]; d++){
        const c = deck.pop();
        c.faceUp = false;
        tableau[col].push(c);
      }
      const up = deck.pop();
      up.faceUp = true;
      tableau[col].push(up);
    }

    stock = deck;
    deals = 0;

    refreshAllAnchors();
    updateUI();
    render();
  }

  function updateUI(disable=false){
    document.getElementById('undo').disabled = disable || undoStack.length===0;
  }
  function showMessage(t){
    document.getElementById('messageText').textContent = t;
    document.getElementById('message').style.display = 'flex';
    updateUI(true);
  }
  function hideMessage(){ document.getElementById('message').style.display = 'none'; }

  function getCanvasPos(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  function computeTableauSnapTarget(moving, drop, x, y){
    if (!moving) return null;
    const fromCol = drag && drag.from && drag.from.type === 'tableau' ? drag.from.col : null;

    if (drop && drop.type === 'tableau'){
      if (!canPlaceOnTableau(moving, drop.col)) return null;
      if (fromCol !== null && drop.col === fromCol && drop.row >= drag.from.idx) return null;
      let depth = drop.row >= 0 ? drop.row + 1 : tableau[drop.col].length;
      if (fromCol !== null && drop.col === fromCol){
        depth = Math.max(drag.from.idx, depth - drag.cards.length);
      }
      const snapY = tableauTopY() + depth * OVERLAP;
      return { x: colX(drop.col), y: snapY, target: { type: 'tableau', col: drop.col }, strength: 0.88 };
    }

    let best = null;
    const topY = tableauTopY();
    for (let col = 0; col < tableau.length; col++){
      if (fromCol !== null && col === fromCol) continue;
      if (!canPlaceOnTableau(moving, col)) continue;
      const baseX = colX(col);
      const centerX = baseX + CARD_W / 2;
      const dx = Math.abs(x - centerX);
      const dy = y < topY ? topY - y : 0;
      const score = dx * dx + dy * dy * 0.35;
      if (!best || score < best.score){
        best = { col, score };
      }
    }

    if (!best) return null;
    const depth = tableau[best.col].length;
    const snapY = tableauTopY() + depth * OVERLAP;
    return { x: colX(best.col), y: snapY, target: { type: 'tableau', col: best.col }, strength: 0.82 };
  }

  function computeDragSnap(x, y){
    if (!drag) return null;
    const drop = hitAt(x, y, true);
    const moving = drag.cards[0];

    if (drop && drop.type === 'foundation'){
      if (drag.cards.length !== 1) return null;
      if (!canPlaceOnFoundation(moving, drop.idx)) return null;
      const slot = TopGeom.fSlots[drop.idx];
      if (!slot) return null;
      return { x: slot.x, y: slot.y, strength: 0.92, target: { type: 'foundation', idx: drop.idx } };
    }

    const tableSnap = computeTableauSnapTarget(moving, drop, x, y);
    return tableSnap;
  }

  function handlePrimaryMove(x, y){
    mouseX = x;
    mouseY = y;
    if (drag){
      drag.renderX = x - drag.offsetX;
      drag.renderY = y - drag.offsetY;
      drag.snap = computeDragSnap(x, y);
      queueDraw();
    }
  }

  function handlePrimaryDown(x, y){
    mouseX = x;
    mouseY = y;
    if (isAnimatingDeal) return false;
    const hit = hitAt(x, y);
    if (!hit) return false;

    if (hit.type === 'stock'){
      doDeal();
      return true;
    }

    if (hit.type === 'tableau'){
      if (hit.row < 0) return false;
      if (!canStartDragAt(hit.col, hit.row)) return false;
      const runLen = getRunLength(hit.col, hit.row);
      const origin = tableauCardPos(hit.col, hit.row);
      const offsetX = Math.max(0, Math.min(CARD_W, x - origin.x));
      const offsetY = Math.max(0, Math.min(CARD_H, y - origin.y));
      drag = {
        from: {type:'tableau', col:hit.col, idx:hit.row},
        cards: tableau[hit.col].slice(hit.row, hit.row + runLen),
        offsetX,
        offsetY,
        renderX: origin.x,
        renderY: origin.y,
        snap: null
      };
      drag.snap = computeDragSnap(x, y);
      queueDraw();
      return true;
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      const origin = devilsCardPos(hit.idx);
      const offsetX = Math.max(0, Math.min(CARD_W, x - origin.x));
      const offsetY = Math.max(0, Math.min(CARD_H, y - origin.y));
      drag = {
        from:{type:'devils', idx:hit.idx},
        cards:[card],
        offsetX,
        offsetY,
        renderX: origin.x,
        renderY: origin.y,
        snap: null
      };
      drag.snap = computeDragSnap(x, y);
      queueDraw();
      return true;
    }

    return false;
  }

  function handlePrimaryUp(x, y){
    if (!drag){
      mouseX = x;
      mouseY = y;
      return false;
    }
    mouseX = x;
    mouseY = y;
    let drop = hitAt(mouseX, mouseY, true);
    const moving = drag.cards[0];
    let moved = false;

    const snapTarget = drag.snap ? drag.snap.target : null;
    if (snapTarget){
      const mismatch =
        !drop ||
        drop.type !== snapTarget.type ||
        (drop.type === 'foundation' && drop.idx !== snapTarget.idx) ||
        (drop.type === 'tableau' && drop.col !== snapTarget.col);
      if (mismatch){
        drop = { ...snapTarget };
      } else {
        if (drop.type === 'foundation' && drop.idx === undefined) drop.idx = snapTarget.idx;
        if (drop.type === 'tableau' && drop.col === undefined) drop.col = snapTarget.col;
      }
    }

    if (drop){
      // to foundation
      if (drop.type === 'foundation' && drag.cards.length === 1 && canPlaceOnFoundation(moving, drop.idx)){
        foundations[drop.idx].push(moving);
        if (drag.from.type === 'tableau'){
          tableau[drag.from.col].splice(drag.from.idx,1);
          flipTop(drag.from.col);
        } else {
          devilsSix.splice(drag.from.idx,1);
        }
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        moved = true;
      }
      // tableau-to-tableau
      else if (drop.type === 'tableau' && drag.from.type === 'tableau' && canPlaceOnTableau(moving, drop.col)){
        const run = drag.cards.slice();
        const toCol = drop.col;
        const fromCol = drag.from.col;
        tableau[toCol].push(...run);
        tableau[fromCol].splice(drag.from.idx, run.length);
        refreshAnchorForColumn(toCol);
        flipTop(fromCol);

        undoStack.push({
          kind:'tab2tab',
          from:{col:fromCol, idx:drag.from.idx},
          toCol:toCol,
          count:run.length
        });
        moved = true;
      }
      else if (drop.type === 'tableau' && drag.from.type === 'devils' && canPlaceOnTableau(moving, drop.col)){
        const toCol = drop.col;
        tableau[toCol].push(moving);
        devilsSix.splice(drag.from.idx,1);
        refreshAnchorForColumn(toCol);
        undoStack.push({
          kind:'devils2tab',
          toCol,
          fromIdx: drag.from.idx
        });
        moved = true;
      }
    }

    drag = null;
    render();
    if (moved){
      updateUI();
      checkWinOrStuck();
    }
    return moved;
  }

  function cancelDrag(){
    if (drag){
      drag = null;
      render();
    }
  }

  canvas.addEventListener('contextmenu', e=> e.preventDefault());
  canvas.addEventListener('dblclick', e=>{
    const pos = getCanvasPos(e.clientX, e.clientY);
    if (attemptAutoFoundationAt(pos.x, pos.y)) e.preventDefault();
  });

  const supportsPointer = 'PointerEvent' in window;
  let lastMouseClickTime = 0;
  let lastMouseClickPos = null;
  const CLICK_INTERVAL = 320;
  const CLICK_SLOP_SQ = 24 * 24;
  if (supportsPointer){
    let activePointerId = null;
    let tapCandidate = null;
    let lastTapTime = 0;
    let lastTapPos = null;
    const TAP_INTERVAL = 320;
    const TAP_SLOP_SQ = 26 * 26;
    const isPrimaryPointer = e => {
      if (e.pointerType === 'mouse') return e.button === 0;
      return true;
    };
    const registerTap = pos => {
      const now = performance.now();
      if (lastTapPos && now - lastTapTime <= TAP_INTERVAL){
        const dx = pos.x - lastTapPos.x;
        const dy = pos.y - lastTapPos.y;
        if (dx*dx + dy*dy <= TAP_SLOP_SQ){
          if (attemptAutoFoundationAt(pos.x, pos.y)){
            lastTapTime = 0;
            lastTapPos = null;
            return;
          }
        }
      }
      lastTapTime = now;
      lastTapPos = {x: pos.x, y: pos.y};
    };
    canvas.addEventListener('pointerdown', e=>{
      if (activePointerId !== null) return;
      if (!isPrimaryPointer(e)) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      const startedDrag = !!drag;
      if (startedDrag){
        try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
        activePointerId = e.pointerId;
      }
      if (handled && e.pointerType !== 'mouse') e.preventDefault();
      if (e.pointerType !== 'mouse'){
        tapCandidate = handled
          ? {
              pointerId: e.pointerId,
              pointerType: e.pointerType,
              startPos: {x: pos.x, y: pos.y},
              lastPos: {x: pos.x, y: pos.y},
              moved: false
            }
          : null;
      }
    }, {passive:false});
    canvas.addEventListener('pointermove', e=>{
      if (activePointerId === e.pointerId){
        const pos = getCanvasPos(e.clientX, e.clientY);
        handlePrimaryMove(pos.x, pos.y);
        if (tapCandidate && tapCandidate.pointerId === e.pointerId){
          const dx = pos.x - tapCandidate.startPos.x;
          const dy = pos.y - tapCandidate.startPos.y;
          if (dx*dx + dy*dy > TAP_SLOP_SQ) tapCandidate.moved = true;
          tapCandidate.lastPos = {x: pos.x, y: pos.y};
        }
        if (drag && e.pointerType !== 'mouse') e.preventDefault();
        return;
      }
      if (tapCandidate && tapCandidate.pointerId === e.pointerId){
        const pos = getCanvasPos(e.clientX, e.clientY);
        const dx = pos.x - tapCandidate.startPos.x;
        const dy = pos.y - tapCandidate.startPos.y;
        if (dx*dx + dy*dy > TAP_SLOP_SQ) tapCandidate.moved = true;
        tapCandidate.lastPos = {x: pos.x, y: pos.y};
      }
    }, {passive:false});
    const finishPointer = e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      const movedByDrag = handlePrimaryUp(pos.x, pos.y);
      if (activePointerId === e.pointerId){
        activePointerId = null;
        try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      }
      if (tapCandidate && tapCandidate.pointerId === e.pointerId){
        const candidate = tapCandidate;
        tapCandidate = null;
        if (candidate.pointerType !== 'mouse' && !candidate.moved && !movedByDrag){
          registerTap(candidate.lastPos);
        }
      }
      if (e.pointerType === 'mouse' && movedByDrag){
        lastMouseClickTime = 0;
        lastMouseClickPos = null;
      }
      if (e.pointerType === 'mouse' && !movedByDrag){
        const now = performance.now();
        if (lastMouseClickPos && now - lastMouseClickTime <= CLICK_INTERVAL){
          const dx = pos.x - lastMouseClickPos.x;
          const dy = pos.y - lastMouseClickPos.y;
          if (dx * dx + dy * dy <= CLICK_SLOP_SQ){
            if (attemptAutoFoundationAt(pos.x, pos.y)){
              lastMouseClickTime = 0;
              lastMouseClickPos = null;
            } else {
              lastMouseClickTime = now;
              lastMouseClickPos = { x: pos.x, y: pos.y };
            }
          } else {
            lastMouseClickTime = now;
            lastMouseClickPos = { x: pos.x, y: pos.y };
          }
        } else {
          lastMouseClickTime = now;
          lastMouseClickPos = { x: pos.x, y: pos.y };
        }
      }
      if (e.pointerType !== 'mouse') e.preventDefault();
    };
    canvas.addEventListener('pointerup', finishPointer, {passive:false});
    window.addEventListener('pointerup', finishPointer, {passive:false});
    const cancelPointer = e=>{
      if (activePointerId !== e.pointerId) return;
      activePointerId = null;
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      cancelDrag();
      tapCandidate = null;
      if (e.pointerType !== 'mouse') e.preventDefault();
    };
    canvas.addEventListener('pointercancel', cancelPointer, {passive:false});
    window.addEventListener('pointercancel', cancelPointer, {passive:false});
    canvas.addEventListener('lostpointercapture', e=>{
      if (activePointerId !== e.pointerId) return;
      activePointerId = null;
      tapCandidate = null;
      cancelDrag();
    });
  } else {
    canvas.addEventListener('mousemove', e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      handlePrimaryMove(pos.x, pos.y);
    });
    canvas.addEventListener('mousedown', e=>{
      if (e.button !== 0) return;
      const pos = getCanvasPos(e.clientX, e.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      if (handled) e.preventDefault();
    });
    window.addEventListener('mouseup', e=>{
      const pos = getCanvasPos(e.clientX, e.clientY);
      const moved = handlePrimaryUp(pos.x, pos.y);
      if (e.button !== 0) return;
      if (!moved){
        const now = performance.now();
        if (lastMouseClickPos && now - lastMouseClickTime <= CLICK_INTERVAL){
          const dx = pos.x - lastMouseClickPos.x;
          const dy = pos.y - lastMouseClickPos.y;
          if (dx * dx + dy * dy <= CLICK_SLOP_SQ){
            if (attemptAutoFoundationAt(pos.x, pos.y)){
              lastMouseClickTime = 0;
              lastMouseClickPos = null;
              return;
            }
          }
        }
        lastMouseClickTime = now;
        lastMouseClickPos = { x: pos.x, y: pos.y };
      } else {
        lastMouseClickTime = 0;
        lastMouseClickPos = null;
      }
    });

    let activeTouchId = null;
    let tapTouchCandidate = null;
    let lastTouchTime = 0;
    let lastTouchPos = null;
    const TOUCH_INTERVAL = 320;
    const TOUCH_SLOP_SQ = 26 * 26;
    canvas.addEventListener('touchstart', e=>{
      if (activeTouchId !== null) return;
      const touch = e.changedTouches[0];
      if (!touch) return;
      const pos = getCanvasPos(touch.clientX, touch.clientY);
      const handled = handlePrimaryDown(pos.x, pos.y);
      const startedDrag = !!drag;
      if (!handled) return;
      if (startedDrag) {
        activeTouchId = touch.identifier;
      }
      tapTouchCandidate = {
        identifier: touch.identifier,
        startPos: {x: pos.x, y: pos.y},
        lastPos: {x: pos.x, y: pos.y},
        moved: false
      };
      e.preventDefault();
    }, {passive:false});
    window.addEventListener('touchmove', e=>{
      let prevent = false;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        const pos = getCanvasPos(touch.clientX, touch.clientY);
        if (activeTouchId !== null && touch.identifier === activeTouchId){
          handlePrimaryMove(pos.x, pos.y);
          if (drag) prevent = true;
        }
        if (tapTouchCandidate && tapTouchCandidate.identifier === touch.identifier){
          const dx = pos.x - tapTouchCandidate.startPos.x;
          const dy = pos.y - tapTouchCandidate.startPos.y;
          if (dx*dx + dy*dy > TOUCH_SLOP_SQ) tapTouchCandidate.moved = true;
          tapTouchCandidate.lastPos = {x: pos.x, y: pos.y};
        }
      }
      if (prevent) e.preventDefault();
    }, {passive:false});
    const finishTouch = e=>{
      let handled = false;
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        const matchesDrag = activeTouchId !== null && touch.identifier === activeTouchId;
        const matchesTap = tapTouchCandidate && tapTouchCandidate.identifier === touch.identifier;
        if (!matchesDrag && !matchesTap) continue;
        const pos = getCanvasPos(touch.clientX, touch.clientY);
        const movedByDrag = handlePrimaryUp(pos.x, pos.y);
        if (matchesDrag) {
          activeTouchId = null;
        }
        if (matchesTap){
          const candidate = tapTouchCandidate;
          tapTouchCandidate = null;
          if (!candidate.moved && !movedByDrag){
            const now = performance.now();
            if (lastTouchPos && now - lastTouchTime <= TOUCH_INTERVAL){
              const dx = candidate.lastPos.x - lastTouchPos.x;
              const dy = candidate.lastPos.y - lastTouchPos.y;
              if (dx*dx + dy*dy <= TOUCH_SLOP_SQ){
                if (attemptAutoFoundationAt(candidate.lastPos.x, candidate.lastPos.y)){
                  lastTouchTime = 0;
                  lastTouchPos = null;
                  handled = true;
                  continue;
                }
              }
            }
            lastTouchTime = now;
            lastTouchPos = {x: candidate.lastPos.x, y: candidate.lastPos.y};
          }
        }
        handled = true;
      }
      if (handled) e.preventDefault();
    };
    window.addEventListener('touchend', finishTouch, {passive:false});
    window.addEventListener('touchcancel', e=>{
      for (let i=0;i<e.changedTouches.length;i++){
        const touch = e.changedTouches[i];
        if (activeTouchId !== null && touch.identifier === activeTouchId){
          activeTouchId = null;
          cancelDrag();
        }
        if (tapTouchCandidate && tapTouchCandidate.identifier === touch.identifier){
          tapTouchCandidate = null;
        }
      }
    });
  }

  document.getElementById('undo').addEventListener('click', ()=>{
    if (isAnimatingDeal) return;
    if (!undoStack.length) return;
    const step = undoStack.pop();
    if (step.kind === 'deal'){
      const touched = new Set();
      for (let i=step.payload.length-1;i>=0;i--){
        const {col,card} = step.payload[i];
        tableau[col].pop();
        card.faceUp = false;
        stock.push(card);
        touched.add(col);
      }
      deals = Math.max(0, deals-1);
      touched.forEach(refreshAnchorForColumn);
    } else if (step.kind === 'tab2tab'){
      const moved = tableau[step.toCol].splice(-step.count, step.count);
      tableau[step.from.col].splice(step.from.idx, 0, ...moved);
      refreshAnchorForColumn(step.toCol);
      flipTop(step.from.col);
    } else if (step.kind === 'devils2tab'){
      const card = tableau[step.toCol].pop();
      if (card){
        devilsSix.splice(step.fromIdx,0,card);
      }
      refreshAnchorForColumn(step.toCol);
    } else if (step.kind === 'toFound'){
      const card = foundations[step.fIdx].pop();
      if (step.from.type === 'tableau'){
        tableau[step.from.col].splice(step.from.idx,0,card);
        refreshAnchorForColumn(step.from.col);
      } else {
        devilsSix.splice(step.from.idx,0,card);
      }
    }
    render();
    updateUI();
  });

  document.getElementById('newGame').addEventListener('click', ()=>{
    if (isAnimatingDeal) return;
    hideMessage();
    newGame();
  });
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideMessage(); newGame(); });

  function runTests(){
    const results = [];
    results.push(['8 foundations', Array.isArray(foundations) && foundations.length === 8]);
    results.push(['10 tableau columns', Array.isArray(tableau) && tableau.length === 10]);
    results.push(['Devil’s Six is 6 cards', Array.isArray(devilsSix) && devilsSix.length === 6]);
    results.push(['Devil’s Six faceup', devilsSix.every(c => c && c.faceUp)]);
    const failed = results.filter(r=>!r[1]);
    const el = document.getElementById('testout');
    if (el){
      el.textContent = failed.length
        ? `Tests: ${results.length - failed.length}/${results.length} passed, ${failed.length} failed`
        : `Tests: ${results.length} passed`;
    }
  }

  resizeCanvas();
  newGame();
  runTests();
  </script>
</body>
</html>
