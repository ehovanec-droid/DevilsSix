<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Churchill Solitaire â€” Devil's Six</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(ellipse at center, #0e6a30 0%, #06421d 70%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #fff;
      overflow: hidden;
      user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; }
    #ui { position: absolute; top: 12px; left: 12px; z-index: 2; }
    .btn { background: rgba(0,0,0,.6); color: #fff; border: 2px solid #e6c229; padding: 9px 14px; margin: 0 6px 6px 0; border-radius: 8px; font-weight: 700; cursor: pointer; }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    #status { position: absolute; top: 12px; right: 12px; text-align: right; font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,.6); }
    #message { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,.85); padding: 28px 32px; border: 3px solid #e6c229; border-radius: 12px; display: none; z-index: 3; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="newGame" class="btn">New Game</button>
    <button id="deal" class="btn">Deal</button>
    <button id="hint" class="btn">Hint</button>
    <button id="undo" class="btn">Undo</button>
  </div>
  <div id="status">
    <div>Time: <span id="time">00:00</span></div>
    <div>Deals: <span id="deals">0</span></div>
    <div>Career: <span id="careerScore">0</span></div>
  </div>
  <div id="message">
    <div id="messageText" style="margin-bottom:14px;font-size:20px"></div>
    <div style="text-align:center"><button id="playAgain" class="btn">Play Again</button></div>
  </div>
  <canvas id="game"></canvas>
  <script>
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resizeCanvas(){
    const {width, height} = canvas.getBoundingClientRect();
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
  const COLORS = {'\u2660':'black','\u2663':'black','\u2665':'red','\u2666':'red'};
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL = {A:1,J:11,Q:12,K:13};
  for(let i=2;i<=10;i++) RVAL[i]=i;

  class Card { constructor(suit,rank){this.suit=suit;this.rank=rank;this.faceUp=false;} get color(){return COLORS[this.suit]} get value(){return RVAL[this.rank]} get name(){return this.rank+this.suit} }

  // State
  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]); // 0&4 spade, 1&5 heart, 2&6 diamond, 3&7 club
  let stock = [];
  let deck = [];
  let deals = 0;
  let timeStart = 0, ticker = null;
  let undoStack = [];
  let career = +localStorage.getItem('careerScore') || 0; document.getElementById('careerScore').textContent = career;

  // Layout sizing
  let CARD_W=80, CARD_H=120, OVERLAP=24;
  const PADDING = 16;
  function layout(){
    const w = canvas.getBoundingClientRect().width;
    CARD_W = Math.max(60, Math.min(90, Math.floor((w - PADDING*2) / 14)));
    CARD_H = Math.floor(CARD_W * 1.5);
    OVERLAP = Math.floor(CARD_H * 0.30);
  }

  function spacingX(){
    const w = canvas.getBoundingClientRect().width;
    const totalCards = CARD_W*10; const free = Math.max(0, w - totalCards - PADDING*2);
    return PADDING + free/11; // left margin
  }
  function colX(col){ return spacingX() + col*(CARD_W + ( (canvas.getBoundingClientRect().width - PADDING*2 - CARD_W*10)/11 )); }
  function tableauTopY(){ return CARD_H + 48; }

  function buildDeck(){
    deck = [];
    for(let d=0; d<2; d++) for(const s of SUITS) for(const r of RANKS) deck.push(new Card(s,r));
    for(let i=deck.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
  }

  function newGame(){
    buildDeck();
    tableau = new Array(10).fill(0).map(()=>[]);
    devilsSix = [];
    foundations = new Array(8).fill(0).map(()=>[]);
    stock = [];
    undoStack = [];

    for(let i=0;i<6;i++){ const c=deck.pop(); c.faceUp=true; devilsSix.push(c); }
    const downs=[0,1,2,3,4,4,3,2,1,0];
    for(let col=0; col<10; col++){
      for(let d=0; d<downs[col]; d++){ const c=deck.pop(); c.faceUp=false; tableau[col].push(c);} 
      const up=deck.pop(); up.faceUp=true; tableau[col].push(up);
    }
    stock = deck; // remainder face-down
    deals = 0; document.getElementById('deals').textContent = deals;
    timeStart = Date.now(); if(ticker) clearInterval(ticker); ticker=setInterval(()=>{
      const s = Math.floor((Date.now()-timeStart)/1000); const m=(s/60|0).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0');
      document.getElementById('time').textContent = `${m}:${ss}`;
    },1000);
    autoMoveAces();
    updateUI();
    draw();
  }

  function drawCard(card,x,y,opts={}){
    const {ghost=false, highlight=false, emptyHint=false, foundationSuit=null} = opts;
    ctx.save();
    ctx.translate(x,y);
    if(highlight) { ctx.shadowColor='rgba(230,194,41,.9)'; ctx.shadowBlur=16; }
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2;
    ctx.globalAlpha = ghost?0.8:1;

    if(card){
      ctx.fillRect(0,0,CARD_W,CARD_H); ctx.strokeRect(0,0,CARD_W,CARD_H);
      if(card.faceUp){
        ctx.fillStyle = (card.color==='red') ? '#c72a2a' : '#111';
        ctx.font = `bold ${Math.floor(CARD_W/3)}px system-ui`;
        ctx.textAlign='left'; ctx.textBaseline='top';
        ctx.fillText(card.rank,6,4);
        ctx.fillText(card.suit,6,Math.floor(CARD_H/2));
        ctx.save(); ctx.translate(CARD_W-6,CARD_H-4); ctx.rotate(Math.PI);
        ctx.fillText(card.rank,0,0); ctx.fillText(card.suit,0,Math.floor(CARD_H/2)); ctx.restore();
      } else {
        ctx.fillStyle = '#1f4aa8'; ctx.fillRect(4,4,CARD_W-8,CARD_H-8);
        ctx.strokeStyle='#d9e2ff'; ctx.strokeRect(8,8,CARD_W-16,CARD_H-16);
      }
    } else {
      // empty slot
      ctx.setLineDash([6,6]); ctx.strokeStyle = '#e6c229'; ctx.strokeRect(0,0,CARD_W,CARD_H); ctx.setLineDash([]);
      if(emptyHint && foundationSuit){
        ctx.fillStyle='#888'; ctx.font=`bold ${Math.floor(CARD_W/3)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('A'+foundationSuit, CARD_W/2, CARD_H/2);
      }
    }
    ctx.restore();
  }

  function draw(){
    layout();
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    // Foundations row (top-right)
    const fs = CARD_W + 10; // spacing
    const fStartX = Math.max(PADDING, r.width - fs*8 - PADDING);
    const fY = PADDING;
    for(let i=0;i<8;i++){
      const stack = foundations[i]; const top = stack[stack.length-1]||null;
      drawCard(top, fStartX + i*fs, fY, {emptyHint:!top, foundationSuit: SUITS[i%4]});
    }

    // Devil's Six (top-left)
    const dsX = PADDING, dsY = PADDING;
    for(let i=0;i<devilsSix.length;i++) drawCard(devilsSix[i], dsX + i*(CARD_W+6), dsY);

    // Stock (right of DS)
    const stockX = dsX + 6*(CARD_W+6) + 12, stockY = dsY;
    drawCard(stock.length? {faceUp:false}: null, stockX, stockY);
    stockHitRect = {x:stockX,y:stockY,w:CARD_W,h:CARD_H};

    // Tableau columns
    const tY = tableauTopY();
    for(let c=0;c<10;c++){
      const x = colX(c);
      if(tableau[c].length===0) drawCard(null,x,tY);
      else {
        for(let i=0;i<tableau[c].length;i++){
          const card = tableau[c][i];
          // If this card belongs to current drag run, it will be re-drawn later as a floating stack
          if(drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
          drawCard(card, x, tY + i*OVERLAP);
        }
      }
    }

    // Draw the dragged run on top
    if(drag){
      const cards = drag.cards;
      for(let i=0;i<cards.length;i++){
        drawCard(cards[i], mouseX - CARD_W/2, mouseY - CARD_H/2 + i*OVERLAP, {ghost:true, highlight:true});
      }
    }
  }

  // --- Hit testing & interactions ---
  let mouseX=0, mouseY=0; let stockHitRect = {x:0,y:0,w:0,h:0};
  canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; if(drag) draw(); });

  function cardAt(x,y){
    // Foundations areas
    const fs = CARD_W + 10; const r = canvas.getBoundingClientRect(); const fStartX=Math.max(PADDING, r.width - fs*8 - PADDING); const fY=PADDING;
    for(let i=0;i<8;i++){
      const fx=fStartX+i*fs; if(x>fx && x<fx+CARD_W && y>fY && y<fY+CARD_H) return {type:'foundation', idx:i};
    }
    // Devil's Six
    const dsX=PADDING, dsY=PADDING; for(let i=0;i<devilsSix.length;i++){ const dx=dsX+i*(CARD_W+6); if(x>dx&&x<dx+CARD_W&&y>dsY&&y<dsY+CARD_H) return {type:'devils', idx:i}; }
    // Stock
    if(stock.length && x>stockHitRect.x && x<stockHitRect.x+CARD_W && y>stockHitRect.y && y<stockHitRect.y+CARD_H) return {type:'stock'};
    // Tableau cells top-down so higher cards win
    const tY = tableauTopY();
    for(let c=0;c<10;c++){
      const cx=colX(c); const col=tableau[c];
      if(col.length===0){ if(x>cx&&x<cx+CARD_W&&y>tY&&y<tY+CARD_H) return {type:'tableau', col:c, row:-1}; continue; }
      for(let i=col.length-1;i>=0;i--){ const cy=tY+i*OVERLAP; if(x>cx&&x<cx+CARD_W&&y>cy&&y<cy+CARD_H){ return {type:'tableau', col:c, row:i}; }
      }
    }
    return null;
  }

  function getRunLength(col, startIdx){
    let len=1; const c = tableau[col];
    for(let i=startIdx+1;i<c.length;i++){
      const prev=c[i-1], cur=c[i]; if(!cur.faceUp) break; if(prev.color===cur.color) break; if(cur.value!==prev.value-1) break; len++;
    }
    return len;
  }

  function canPlaceOnTableau(card, toCol){
    const t = tableau[toCol]; const top=t[t.length-1];
    if(!top) return card.value===13; // only Kings to empty
    return (card.color!==top.color) && (card.value===top.value-1);
  }

  function canPlaceOnFoundation(card, fIdx){
    if(SUITS[fIdx%4] !== card.suit) return false; const stack = foundations[fIdx]; const top=stack[stack.length-1];
    return top ? (card.value === top.value+1) : (card.value===1);
  }

  let drag=null; // {from:{type:'tableau'|'devils', col?, row?, idx?}, cards:Card[]}

  canvas.addEventListener('mousedown', e=>{
    const r = canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top;
    const hit = cardAt(mouseX, mouseY);
    if(!hit) return;
    if(hit.type==='stock'){ doDeal(); return; }
    if(hit.type==='tableau'){
      const col = hit.col; const row = hit.row;
      if(row<0) return; const card = tableau[col][row]; if(!card || !card.faceUp) return;
      const len = getRunLength(col,row); const cards = tableau[col].slice(row,row+len);
      drag = {from:{type:'tableau', col, idx:row}, cards}; draw();
    }
    if(hit.type==='devils'){
      const card = devilsSix[hit.idx]; if(!card) return; // DS can only move singly to foundations
      drag = {from:{type:'devils', idx:hit.idx}, cards:[card]}; draw();
    }
  });
  window.addEventListener('mouseup', e=>{
    if(!drag) return; const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; const drop=cardAt(mouseX,mouseY);
    const moving = drag.cards[0];
    let moved=false;
    if(drop){
      if(drop.type==='foundation' && drag.cards.length===1 && canPlaceOnFoundation(moving, drop.idx)){
        // record undo
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        // execute
        if(drag.from.type==='tableau'){ tableau[drag.from.col].splice(drag.from.idx,1); flipTop(drag.from.col); }
        else { devilsSix.splice(drag.from.idx,1); }
        foundations[drop.idx].push(moving); moved=true; autoMoveAces();
      }
      if(!moved && drop.type==='tableau' && drag.from.type==='tableau' && canPlaceOnTableau(moving, drop.col)){
        const fromCol = drag.from.col; const fromIdx = drag.from.idx; const run = drag.cards.slice();
        undoStack.push({kind:'tab2tab', from:{col:fromCol, idx:fromIdx}, toCol:drop.col, count:run.length});
        tableau[drop.col].push(...run);
        tableau[fromCol].splice(fromIdx, run.length); flipTop(fromCol); moved=true;
      }
    }
    drag=null; draw();
    if(moved){ updateUI(); checkWinOrStuck(); }
  });

  function flipTop(col){ const t=tableau[col]; if(t.length && !t[t.length-1].faceUp) t[t.length-1].faceUp=true; }

  function autoMoveAces(){
    // Tableau first
    for(let c=0;c<10;c++){
      for(let i=0;i<tableau[c].length;i++){
        const card = tableau[c][i];
        if(card.faceUp && card.value===1){
          for(let f=0; f<8; f++) if(SUITS[f%4]===card.suit && foundations[f].length===0){ foundations[f].push(card); tableau[c].splice(i,1); flipTop(c); i--; break; }
        }
      }
    }
    // Devil's Six
    for(let i=0;i<devilsSix.length;i++){
      const card=devilsSix[i]; if(card.value!==1) continue;
      for(let f=0; f<8; f++) if(SUITS[f%4]===card.suit && foundations[f].length===0){ foundations[f].push(card); devilsSix.splice(i,1); i--; break; }
    }
  }

  function doDeal(){
    if(!stock.length) return;
    const dealt=[];
    for(let c=0;c<10;c++){
      const t=tableau[c]; const top=t[t.length-1];
      if(!top || top.value!==13){ const card=stock.pop(); card.faceUp=true; t.push(card); dealt.push({col:c,card}); }
    }
    if(dealt.length){ deals++; document.getElementById('deals').textContent = deals; undoStack.push({kind:'deal', dealt}); autoMoveAces(); draw(); updateUI(); checkWinOrStuck(); }
  }

  function hasAnyMoves(){
    // Devil's Six to foundation
    if(devilsSix.some(c=>foundations.some((_,i)=>canPlaceOnFoundation(c,i)))) return true;
    // Tableau top to foundation
    for(let c=0;c<10;c++){ const t=tableau[c]; const top=t[t.length-1]; if(top && foundations.some((_,i)=>canPlaceOnFoundation(top,i))) return true; }
    // Tableau runs between columns
    for(let from=0; from<10; from++){
      const t=tableau[from]; let start=t.findIndex(c=>c.faceUp); if(start<0) continue;
      for(let i=start;i<t.length;i++){
        const len=getRunLength(from,i); const base=t[i];
        for(let to=0; to<10; to++){ if(to===from) continue; if(canPlaceOnTableau(base,to)) return true; }
      }
    }
    return false;
  }

  function checkWinOrStuck(){
    const totalFound = foundations.reduce((n,s)=>n+s.length,0);
    if(totalFound===104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      const secs = Math.floor((Date.now()-timeStart)/1000); career = career + Math.max(100, 1000 - deals*100 - Math.floor(secs/10)); localStorage.setItem('careerScore', career); document.getElementById('careerScore').textContent = career;
      showMessage('Victory! All eight foundations completed.'); return;
    }
    if(!stock.length && !hasAnyMoves()) showMessage('Stuck. No more moves and stock is empty.');
  }

  function showMessage(t){ document.getElementById('messageText').textContent=t; document.getElementById('message').style.display='block'; updateUI(true); if(ticker) clearInterval(ticker); }
  function hideMessage(){ document.getElementById('message').style.display='none'; }

  function updateUI(end=false){
    document.getElementById('deal').disabled = stock.length===0; // always allow dealing if stock remains
    document.getElementById('undo').disabled = undoStack.length===0;
    if(end){ document.getElementById('deal').disabled = true; document.getElementById('hint').disabled = true; document.getElementById('undo').disabled=true; }
  }

  // Hint: flash first available move source
  function hint(){
    // 1) tableau top to foundation
    for(let c=0;c<10;c++){ const t=tableau[c]; const top=t[t.length-1]; if(top){ for(let f=0;f<8;f++){ if(canPlaceOnFoundation(top,f)){ flashCell(()=>{ const x=colX(c), y=tableauTopY()+ (t.length-1)*OVERLAP; drawCard(top,x,y,{highlight:true}); }); return; } } } }
    // 2) DS to foundation
    for(let i=0;i<devilsSix.length;i++){ const card=devilsSix[i]; for(let f=0;f<8;f++){ if(canPlaceOnFoundation(card,f)){ const x=PADDING+i*(CARD_W+6), y=PADDING; flashCell(()=>drawCard(card,x,y,{highlight:true})); return; } } }
    // 3) tableau run move
    for(let from=0;from<10;from++){ const t=tableau[from]; for(let i=0;i<t.length;i++){ if(!t[i].faceUp) continue; const base=t[i]; for(let to=0;to<10;to++){ if(to===from) continue; if(canPlaceOnTableau(base,to)){ const x=colX(from), y=tableauTopY()+ i*OVERLAP; flashCell(()=>drawCard(base,x,y,{highlight:true})); return; } } } }
  }
  function flashCell(paint){ let n=0; const id=setInterval(()=>{ draw(); if(n%2===0) paint(); if(++n>5) clearInterval(id); },120); }

  // Undo
  document.getElementById('undo').addEventListener('click', ()=>{
    if(!undoStack.length) return; const step=undoStack.pop();
    if(step.kind==='deal'){
      for(let i=step.dealt.length-1;i>=0;i--){ const {col,card}=step.dealt[i]; tableau[col].pop(); card.faceUp=false; stock.push(card); }
      deals = Math.max(0, deals-1); document.getElementById('deals').textContent = deals;
    }
    if(step.kind==='tab2tab'){
      const moved = tableau[step.toCol].splice(-step.count, step.count);
      tableau[step.from.col].splice(step.from.idx, 0, ...moved); flipTop(step.from.col);
    }
    if(step.kind==='toFound'){
      const card = foundations[step.fIdx].pop();
      if(step.from.type==='tableau'){ tableau[step.from.col].splice(step.from.idx,0,card); }
      else { devilsSix.splice(step.from.idx,0,card); }
    }
    draw(); updateUI();
  });

  document.getElementById('newGame').addEventListener('click', ()=>{ hideMessage(); newGame(); });
  document.getElementById('deal').addEventListener('click', doDeal);
  document.getElementById('hint').addEventListener('click', hint);
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideMessage(); newGame(); });

  // boot
  resizeCanvas(); layout(); newGame();
  </script>
</body>
</html>
