<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Churchill Solitaire â€” Devil's Six</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(ellipse at center, #0e6a30 0%, #06421d 70%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #fff;
      overflow: hidden;
      user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; }

    #ui {
      position:absolute;
      top:70px;
      left:16px;
      z-index:2;
      display:flex;
      gap:10px 12px;
      align-items:center;
      background:rgba(0,0,0,.30);
      padding:6px 8px;
      border-radius:8px;
      backdrop-filter: blur(2px);
    }
    .btn {
      background:rgba(0,0,0,.6);
      color:#fff;
      border:2px solid #e6c229;
      padding:8px 14px;
      border-radius:10px;
      font-weight:700;
      cursor:pointer;
      font-size:14px;
      transition:background .15s ease;
    }
    .btn:hover:not(:disabled) { background:rgba(230,194,41,.3); }
    .btn:disabled { opacity:.55; cursor:not-allowed; }

    #status {
      position:absolute;
      top:12px;
      right:12px;
      text-align:right;
      font-weight:700;
      text-shadow:0 2px 6px rgba(0,0,0,.6);
    }
    #message {
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.85);
      padding:28px 32px;
      border:3px solid #e6c229;
      border-radius:12px;
      display:none;
      z-index:3;
    }
    #testout {
      position:absolute;
      bottom:8px;
      left:8px;
      background:rgba(0,0,0,.6);
      padding:6px 8px;
      border-radius:6px;
      font-size:11px;
      max-width:60ch;
      line-height:1.3;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="newGame" class="btn">New Game</button>
    <button id="deal" class="btn">Deal</button>
    <button id="hint" class="btn">Hint</button>
    <button id="undo" class="btn">Undo</button>
  </div>
  <div id="status">
    <div>Time: <span id="time">00:00</span></div>
    <div>Deals: <span id="deals">0</span></div>
    <div>Career: <span id="careerScore">0</span></div>
  </div>
  <div id="message">
    <div id="messageText" style="margin-bottom:14px;font-size:20px"></div>
    <div style="text-align:center"><button id="playAgain" class="btn">Play Again</button></div>
  </div>
  <div id="testout"></div>
  <canvas id="game"></canvas>

  <script>
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
  const COLORS = { '\u2660':'black', '\u2663':'black', '\u2665':'red', '\u2666':'red' };
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL  = { A:1, J:11, Q:12, K:13 };
  for (let i=2;i<=10;i++) RVAL[i]=i;
  const PADDING = 16;

  class Card {
    constructor(suit, rank){
      this.suit = suit;
      this.rank = rank;
      this.value = RVAL[rank];
      this.color = COLORS[suit];
      this.faceUp = false;
    }
  }

  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]);
  let stock = [];
  let deck = [];
  let deals = 0;
  let timeStart = 0;
  let timer = null;
  let undoStack = [];
  let career = +localStorage.getItem('careerScore') || 0;
  document.getElementById('careerScore').textContent = career;

  let CARD_W = 80, CARD_H = 120, OVERLAP = 26;

  const TopGeom = {
    dsX: PADDING,
    dsY: PADDING,
    dsStep: 50,
    stockX: 0,
    stockY: 0,
    fSlots: [],
    fCols: 4,
    fRows: 2,
    fGapX: 10,
    fGapY: 8,
    fY: PADDING
  };

  function layout(){
    const w = canvas.getBoundingClientRect().width;
    CARD_W = Math.max(58, Math.min(90, Math.floor((w - PADDING*2)/14)));
    CARD_H = Math.floor(CARD_W * 1.5);
    OVERLAP = Math.floor(CARD_H * 0.30);
  }
  function tableauGutter(){
    const w = canvas.getBoundingClientRect().width;
    const available = w - PADDING*2 - CARD_W*10;
    return Math.max(4, Math.floor(available/9));
  }
  function colX(c){ return PADDING + c * (CARD_W + tableauGutter()); }
  function tableauTopY(){
    const top = TopGeom.fY + (CARD_H * TopGeom.fRows) + (TopGeom.fGapY * (TopGeom.fRows - 1)) + 24;
    return Math.max(top, CARD_H + 48);
  }
  function computeTopGeometry(){
    const r = canvas.getBoundingClientRect();
    TopGeom.dsX = PADDING;
    TopGeom.dsY = PADDING;
    TopGeom.dsStep = Math.max(Math.floor(CARD_W * 0.62), 34);
    const dsVisualWidth = CARD_W + (6-1)*TopGeom.dsStep;
    TopGeom.stockX = TopGeom.dsX + dsVisualWidth + 14;
    TopGeom.stockY = TopGeom.dsY;

    const totalFW = TopGeom.fCols*CARD_W + (TopGeom.fCols-1)*TopGeom.fGapX;
    const startX = Math.max(TopGeom.stockX + CARD_W + 18, r.width - PADDING - totalFW);
    TopGeom.fSlots = [];
    for (let row=0; row<TopGeom.fRows; row++){
      for (let col=0; col<TopGeom.fCols; col++){
        const x = startX + col*(CARD_W + TopGeom.fGapX);
        const y = TopGeom.fY + row*(CARD_H + TopGeom.fGapY);
        TopGeom.fSlots.push({x,y});
      }
    }
  }
  function placeButtons(){
    const ui = document.getElementById('ui');
    const r = canvas.getBoundingClientRect();
    const dsRight = TopGeom.dsX + CARD_W + (6-1)*TopGeom.dsStep;
    const uiWidth = ui.getBoundingClientRect().width;
    if (dsRight + 14 + uiWidth < r.width - 260) {
      ui.style.left = (dsRight + 14) + 'px';
      ui.style.top = (TopGeom.dsY + 2) + 'px';
    } else {
      ui.style.left = TopGeom.dsX + 'px';
      ui.style.top  = (TopGeom.dsY + CARD_H + 10) + 'px';
    }
  }
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    layout();
    computeTopGeometry();
    placeButtons();
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  let stockHit = {x:0,y:0,w:0,h:0};
  let drag = null;
  let mouseX = 0, mouseY = 0;

  function drawCard(card,x,y,opts={}){
    const {highlight=false,empty=false,suitHint=null,ghost=false} = opts;
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = ghost ? 0.85 : 1;
    if (card){
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 2;
      ctx.fillRect(0,0,CARD_W,CARD_H);
      ctx.strokeRect(0,0,CARD_W,CARD_H);
      if (card.faceUp){
        ctx.fillStyle = card.color === 'red' ? '#c52929' : '#111';
        ctx.font = `bold ${Math.floor(CARD_W/3)}px system-ui`;
        ctx.textAlign='left'; ctx.textBaseline='top';
        ctx.fillText(card.rank,6,4);
        ctx.fillText(card.suit,6,Math.floor(CARD_H/2));
      } else {
        ctx.fillStyle = '#1947a5';
        ctx.fillRect(4,4,CARD_W-8,CARD_H-8);
        ctx.strokeStyle = '#cfd9ff';
        ctx.strokeRect(8,8,CARD_W-16,CARD_H-16);
      }
      if (highlight){
        ctx.strokeStyle = '#ffd54f';
        ctx.lineWidth = 3;
        ctx.strokeRect(1,1,CARD_W-2,CARD_H-2);
      }
    } else {
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = '#e6c229';
      ctx.strokeRect(0,0,CARD_W,CARD_H);
      ctx.setLineDash([]);
      if (suitHint){
        ctx.fillStyle = '#888';
        ctx.font = `bold ${Math.floor(CARD_W/3)}px system-ui`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('A'+suitHint, CARD_W/2, CARD_H/2);
      }
    }
    ctx.restore();
  }

  function draw(){
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    for (let i=0;i<devilsSix.length;i++){
      drawCard(devilsSix[i], TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY);
    }
    drawCard(stock.length ? {faceUp:false} : null, TopGeom.stockX, TopGeom.stockY);
    stockHit = {x:TopGeom.stockX, y:TopGeom.stockY, w:CARD_W, h:CARD_H};

    for (let i=0;i<8;i++){
      const slot = TopGeom.fSlots[i];
      const stack = foundations[i];
      const top = stack.length ? stack[stack.length-1] : null;
      drawCard(top, slot.x, slot.y, {empty:!top, suitHint:SUITS[i%4]});
    }

    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const x = colX(c);
      const col = tableau[c];
      if (!col.length){
        drawCard(null,x,tY);
        continue;
      }
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
        drawCard(card, x, tY + i*OVERLAP);
      }
    }

    if (drag){
      for (let i=0;i<drag.cards.length;i++){
        drawCard(drag.cards[i], mouseX - CARD_W/2, mouseY - CARD_H/2 + i*OVERLAP, {ghost:true,highlight:true});
      }
    }
  }

  function hitAt(x,y){
    for (let i=0;i<8;i++){
      const s = TopGeom.fSlots[i];
      if (x>s.x && x<s.x+CARD_W && y>s.y && y<s.y+CARD_H)
        return {type:'foundation', idx:i};
    }
    for (let i=0;i<devilsSix.length;i++){
      const dx = TopGeom.dsX + i*TopGeom.dsStep, dy=TopGeom.dsY;
      if (x>dx && x<dx+CARD_W && y>dy && y<dy+CARD_H)
        return {type:'devils', idx:i};
    }
    if (stock.length && x>stockHit.x && x<stockHit.x+CARD_W && y>stockHit.y && y<stockHit.y+CARD_H)
      return {type:'stock'};

    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const cx = colX(c);
      const col = tableau[c];
      if (!col.length){
        if (x>cx && x<cx+CARD_W && y>tY && y<tY+CARD_H) return {type:'tableau', col:c, row:-1};
        continue;
      }
      for (let i=col.length-1;i>=0;i--){
        const cy = tY + i*OVERLAP;
        if (x>cx && x<cx+CARD_W && y>cy && y<cy+CARD_H)
          return {type:'tableau', col:c, row:i};
      }
    }
    return null;
  }

  function getRunLength(col, start){
    const arr = tableau[col];
    let len = 1;
    for (let i=start+1;i<arr.length;i++){
      const prev = arr[i-1], cur = arr[i];
      if (!cur.faceUp) break;
      if (prev.color === cur.color) break;
      if (cur.value !== prev.value - 1) break;
      len++;
    }
    return len;
  }
  function canPlaceOnTableau(card, toCol){
    const col = tableau[toCol];
    const top = col[col.length-1];
    if (!top) return card.value === 13;
    return (card.color !== top.color) && (card.value === top.value - 1);
  }
  function canPlaceOnFoundation(card, fIdx){
    if (SUITS[fIdx % 4] !== card.suit) return false;
    const stack = foundations[fIdx];
    const top   = stack[stack.length-1];
    return top ? (card.value === top.value + 1) : (card.value === 1);
  }
  function flipTop(col){
    const colArr = tableau[col];
    if (colArr.length && !colArr[colArr.length-1].faceUp)
      colArr[colArr.length-1].faceUp = true;
  }
  function canStartDragAt(col, row){
    const colArr = tableau[col];
    if (row < 0 || row >= colArr.length) return false;
    const card = colArr[row];
    if (!card.faceUp) return false;
    return true;
  }

  // â˜… FIXED: use your original definition (King + no face-down cards)
  function isKingAnchored(col){
    if (!col.length) return false;
    const top = col[col.length - 1];
    if (!(top.faceUp && top.value === 13)) return false;
    // check that the entire column is exposed
    for (let i = 0; i < col.length; i++){
      if (!col[i].faceUp) return false;
    }
    return true;
  }

  function doDeal(){
    if (!stock.length) {
      draw();
      updateUI();
      return;
    }

    let allAnchored = true;
    for (let c=0;c<10;c++){
      if (!isKingAnchored(tableau[c])) {
        allAnchored = false;
        break;
      }
    }
    if (allAnchored) {
      draw();
      updateUI();
      return;
    }

    const dealt = [];
    for (let c=0;c<10;c++){
      if (!stock.length) break;
      const col = tableau[c];
      if (isKingAnchored(col)) continue;

      const card = stock.pop();
      if (!card) break;
      card.faceUp = true;
      col.push(card);
      dealt.push({col:c, card});
    }

    if (!dealt.length){
      draw();
      updateUI();
      return;
    }

    deals++;
    document.getElementById('deals').textContent = deals;
    undoStack.push({kind:'deal', payload:dealt});
    draw();
    updateUI();
    checkWinOrStuck();
  }

  function hasAnyMoves(){
    for (let c=0;c<10;c++){
      const top = tableau[c][tableau[c].length-1];
      if (!top) continue;
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(top,f)) return true;
    }
    for (const card of devilsSix){
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(card,f)) return true;
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      const start = col.findIndex(c=>c.faceUp);
      if (start<0) continue;
      for (let i=start;i<col.length;i++){
        const base = col[i];
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(base,to)) return true;
        }
      }
    }
    return false;
  }
  function checkWinOrStuck(){
    const total = foundations.reduce((n,s)=>n+s.length,0);
    if (total === 104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      finishGame(true);
      return;
    }
    if (!stock.length && !hasAnyMoves()){
      finishGame(false);
    }
  }
  function finishGame(win){
    if (win){
      const secs = Math.floor((Date.now()-timeStart)/1000);
      const score = Math.max(50, 1000 - deals*100 - Math.floor(secs/10));
      career += score;
      localStorage.setItem('careerScore', career);
      document.getElementById('careerScore').textContent = career;
      showMessage('Victory! Foundations complete.');
    } else {
      showMessage('No more moves.');
    }
  }

  function buildDeck(){
    const temp = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          temp.push(new Card(s,r));
        }
      }
    }
    for (let i=temp.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [temp[i], temp[j]] = [temp[j], temp[i]];
    }
    deck = temp;
  }
  function newGame(){
    buildDeck();
    tableau = new Array(10).fill(0).map(()=>[]);
    devilsSix = [];
    foundations = new Array(8).fill(0).map(()=>[]);
    stock = [];
    undoStack = [];

    for (let i=0;i<6;i++){
      const c = deck.pop();
      c.faceUp = true;
      devilsSix.push(c);
    }

    const downs = [0,1,2,3,4,4,3,2,1,0];
    for (let col=0; col<10; col++){
      for (let d=0; d<downs[col]; d++){
        const c = deck.pop();
        c.faceUp = false;
        tableau[col].push(c);
      }
      const up = deck.pop();
      up.faceUp = true;
      tableau[col].push(up);
    }

    stock = deck;
    deals = 0;
    document.getElementById('deals').textContent = deals;

    timeStart = Date.now();
    if (timer) clearInterval(timer);
    timer = setInterval(()=>{
      const s = Math.floor((Date.now()-timeStart)/1000);
      const m = (s/60|0).toString().padStart(2,'0');
      const ss = (s%60).toString().padStart(2,'0');
      document.getElementById('time').textContent = `${m}:${ss}`;
    },1000);

    updateUI();
    draw();
  }

  function updateUI(disable=false){
    document.getElementById('deal').disabled = disable || stock.length===0;
    document.getElementById('undo').disabled = disable || undoStack.length===0;
    document.getElementById('hint').disabled = disable;
  }
  function showMessage(t){
    document.getElementById('messageText').textContent = t;
    document.getElementById('message').style.display = 'block';
    updateUI(true);
    if (timer) clearInterval(timer);
  }
  function hideMessage(){ document.getElementById('message').style.display = 'none'; }

  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left;
    mouseY = e.clientY - r.top;
    if (drag) draw();
  });

  canvas.addEventListener('mousedown', e=>{
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left;
    mouseY = e.clientY - r.top;
    const hit = hitAt(mouseX, mouseY);
    if (!hit) return;

    if (hit.type === 'stock'){
      doDeal();
      return;
    }

    if (hit.type === 'tableau' && hit.row >= 0){
      const card = tableau[hit.col][hit.row];
      if (card && card.faceUp && card.value === 1){
        const candidates = [];
        for (let f=0;f<8;f++) if (SUITS[f%4] === card.suit) candidates.push(f);
        let placed = false;
        for (const f of candidates){
          if (foundations[f].length === 0){
            foundations[f].push(card);
            tableau[hit.col].splice(hit.row,1);
            flipTop(hit.col);
            undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card});
            placed = true;
            break;
          }
        }
        if (!placed){
          for (const f of candidates){
            if (canPlaceOnFoundation(card, f)){
              foundations[f].push(card);
              tableau[hit.col].splice(hit.row,1);
              flipTop(hit.col);
              undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card});
              placed = true;
              break;
            }
          }
        }
        if (placed){
          draw();
          updateUI();
          checkWinOrStuck();
        }
        return;
      }
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      if (card && card.value === 1){
        const candidates = [];
        for (let f=0;f<8;f++) if (SUITS[f%4] === card.suit) candidates.push(f);
        let placed = false;
        for (const f of candidates){
          if (foundations[f].length === 0){
            foundations[f].push(card);
            devilsSix.splice(hit.idx,1);
            undoStack.push({kind:'toFound', from:{type:'devils',idx:hit.idx}, fIdx:f, card});
            placed = true;
            break;
          }
        }
        if (!placed){
          for (const f of candidates){
            if (canPlaceOnFoundation(card, f)){
              foundations[f].push(card);
              devilsSix.splice(hit.idx,1);
              undoStack.push({kind:'toFound', from:{type:'devils',idx:hit.idx}, fIdx:f, card});
              placed = true;
              break;
            }
          }
        }
        if (placed){
          draw();
          updateUI();
          checkWinOrStuck();
        }
        return;
      }
    }

    if (hit.type === 'tableau'){
      if (hit.row < 0) return;
      if (!canStartDragAt(hit.col, hit.row)) return;
      const runLen = getRunLength(hit.col, hit.row);
      drag = {
        from: {type:'tableau', col:hit.col, idx:hit.row},
        cards: tableau[hit.col].slice(hit.row, hit.row + runLen)
      };
      draw();
      return;
    }

    if (hit.type === 'devils'){
      const card = devilsSix[hit.idx];
      drag = {from:{type:'devils', idx:hit.idx}, cards:[card]};
      draw();
      return;
    }
  });

  window.addEventListener('mouseup', e=>{
    if (!drag) return;
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left;
    mouseY = e.clientY - r.top;
    const drop = hitAt(mouseX, mouseY);
    const moving = drag.cards[0];
    let moved = false;

    if (drop){
      if (drop.type === 'foundation' && drag.cards.length === 1 && canPlaceOnFoundation(moving, drop.idx)){
        foundations[drop.idx].push(moving);
        if (drag.from.type === 'tableau'){
          tableau[drag.from.col].splice(drag.from.idx,1);
          flipTop(drag.from.col);
        } else {
          devilsSix.splice(drag.from.idx,1);
        }
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        moved = true;
      }
      else if (drop.type === 'tableau' && drag.from.type === 'tableau' && canPlaceOnTableau(moving, drop.col)){
        const run = drag.cards.slice();
        tableau[drop.col].push(...run);
        tableau[drag.from.col].splice(drag.from.idx, run.length);
        flipTop(drag.from.col);
        undoStack.push({kind:'tab2tab', from:{col:drag.from.col, idx:drag.from.idx}, toCol:drop.col, count:run.length});
        moved = true;
      }
    }

    drag = null;
    draw();
    if (moved){
      updateUI();
      checkWinOrStuck();
    }
  });

  document.getElementById('undo').addEventListener('click', ()=>{
    if (!undoStack.length) return;
    const step = undoStack.pop();
    if (step.kind === 'deal'){
      for (let i=step.payload.length-1;i>=0;i--){
        const {col,card} = step.payload[i];
        tableau[col].pop();
        card.faceUp = false;
        stock.push(card);
      }
      deals = Math.max(0, deals-1);
      document.getElementById('deals').textContent = deals;
    } else if (step.kind === 'tab2tab'){
      const moved = tableau[step.toCol].splice(-step.count, step.count);
      tableau[step.from.col].splice(step.from.idx, 0, ...moved);
      flipTop(step.from.col);
    } else if (step.kind === 'toFound'){
      const card = foundations[step.fIdx].pop();
      if (step.from.type === 'tableau'){
        tableau[step.from.col].splice(step.from.idx,0,card);
      } else {
        devilsSix.splice(step.from.idx,0,card);
      }
    }
    draw();
    updateUI();
  });

  function hint(){
    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const col = tableau[c];
      const top = col[col.length-1];
      if (!top) continue;
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(top,f)){
          flash(()=>{ drawCard(top, colX(c), tY + (col.length-1)*OVERLAP, {highlight:true}); });
          return;
        }
      }
    }
    for (let i=0;i<devilsSix.length;i++){
      const card = devilsSix[i];
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(card,f)){
          flash(()=>{ drawCard(card, TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY, {highlight:true}); });
          return;
        }
      }
    }
    for (let from=0;from<10;from++){
      const col = tableau[from];
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (!card.faceUp) continue;
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(card,to)){
            flash(()=>{ drawCard(card, colX(from), tY + i*OVERLAP, {highlight:true}); });
            return;
          }
        }
      }
    }
  }
  function flash(paint){
    let n=0;
    const id=setInterval(()=>{
      draw();
      if (n%2===0) paint();
      if (++n>5) clearInterval(id);
    },120);
  }

  document.getElementById('newGame').addEventListener('click', ()=>{ hideMessage(); newGame(); });
  document.getElementById('deal').addEventListener('click', doDeal);
  document.getElementById('hint').addEventListener('click', hint);
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideMessage(); newGame(); });

  function runTests(){
    const results = [];
    results.push(['8 foundations', Array.isArray(foundations) && foundations.length === 8]);
    results.push(['10 tableau columns', Array.isArray(tableau) && tableau.length === 10]);
    results.push(['Devilâ€™s Six is 6 cards', Array.isArray(devilsSix) && devilsSix.length === 6]);
    results.push(['Devilâ€™s Six faceup', devilsSix.every(c => c && c.faceUp)]);
    const failed = results.filter(r=>!r[1]);
    const el = document.getElementById('testout');
    if (el){
      el.textContent = failed.length
        ? `Tests: ${results.length - failed.length}/${results.length} passed, ${failed.length} failed`
        : `Tests: ${results.length} passed`;
    }
  }

  resizeCanvas();
  newGame();
  runTests();
  </script>
</body>
</html>
