<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Churchill Solitaire — Devil's Six</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(ellipse at center, #0e6a30 0%, #06421d 70%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #fff;
      overflow: hidden;
      user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; }

    /* Top controls — more separation and flex layout */
    #ui {
      position: absolute; top: 12px; left: 12px; z-index: 2;
      display: flex; flex-wrap: wrap; gap: 12px;
      align-items: center;
    }
    .btn {
      background: rgba(0,0,0,.6); color: #fff; border: 2px solid #e6c229;
      padding: 10px 16px; border-radius: 10px; font-weight: 700; cursor: pointer;
    }
    .btn:disabled { opacity: .5; cursor: not-allowed; }

    #status { position: absolute; top: 12px; right: 12px; text-align: right; font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,.6); }
    #message { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,.85); padding: 28px 32px; border: 3px solid #e6c229; border-radius: 12px; display: none; z-index: 3; }

    /* Tiny test output overlay */
    #testout { position:absolute; bottom:8px; left:8px; background:rgba(0,0,0,.6); padding:8px 10px; border-radius:8px; font-size:12px; max-width:40ch; line-height:1.3; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="newGame" class="btn">New Game</button>
    <button id="deal" class="btn">Deal</button>
    <button id="hint" class="btn">Hint</button>
    <button id="undo" class="btn">Undo</button>
  </div>
  <div id="status">
    <div>Time: <span id="time">00:00</span></div>
    <div>Deals: <span id="deals">0</span></div>
    <div>Career: <span id="careerScore">0</span></div>
  </div>
  <div id="message">
    <div id="messageText" style="margin-bottom:14px;font-size:20px"></div>
    <div style="text-align:center"><button id="playAgain" class="btn">Play Again</button></div>
  </div>
  <div id="testout" aria-live="polite"></div>
  <canvas id="game"></canvas>
  <script>
  // --- Canvas & DPI ---
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resizeCanvas(){
    const {width, height} = canvas.getBoundingClientRect();
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // --- Cards & State ---
  const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
  const COLORS = {'\u2660':'black','\u2663':'black','\u2665':'red','\u2666':'red'};
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL = {A:1,J:11,Q:12,K:13}; for(let i=2;i<=10;i++) RVAL[i]=i;
  class Card { constructor(suit,rank){this.suit=suit;this.rank=rank;this.faceUp=false;} get color(){return COLORS[this.suit]} get value(){return RVAL[this.rank]} get name(){return this.rank+this.suit} }

  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]);
  let stock = [];
  let deck = [];
  let deals = 0;
  let timeStart = 0, ticker = null;
  let undoStack = [];
  let career = +localStorage.getItem('careerScore') || 0; document.getElementById('careerScore').textContent = career;

  // --- Layout numbers ---
  let CARD_W=80, CARD_H=120, OVERLAP=24; const PADDING=16;
  function layout(){
    const w = canvas.getBoundingClientRect().width;
    CARD_W = Math.max(60, Math.min(90, Math.floor((w - PADDING*2) / 14)));
    CARD_H = Math.floor(CARD_W * 1.5);
    OVERLAP = Math.floor(CARD_H * 0.30);
  }
  function gutter(){ const w=canvas.getBoundingClientRect().width; const available=w - PADDING*2 - CARD_W*10; return Math.max(6, Math.floor(available/9)); }
  function colX(col){ return PADDING + col*(CARD_W + gutter()); }
  function tableauTopY(){ return CARD_H + 56; }

  // We centralize top-row geometry so draw() and cardAt() agree.
  const TopGeom = { dsX:0, dsY:0, dsGap:8, stockX:0, stockY:0, fStartX:0, fY:0, fStep:0, fGap:12, fWidth:0 };
  function computeTopGeometry(){
    const r = canvas.getBoundingClientRect();
    // Devil's Six and Stock (left cluster)
    TopGeom.dsX = PADDING; TopGeom.dsY = PADDING; TopGeom.dsGap = 8;
    const dsWidth = 6*(CARD_W + TopGeom.dsGap) - TopGeom.dsGap; // 6 cards => 5 gaps
    TopGeom.stockX = TopGeom.dsX + dsWidth + 16; TopGeom.stockY = TopGeom.dsY;

    // Foundations row (centered, never overlapping stock). If space is tight,
    // dynamically shrink the inter-pile gap so the full row fits within the viewport.
    const minStart = TopGeom.stockX + CARD_W + 20; // must be to the right of stock
    let avail = (r.width - PADDING) - (minStart + CARD_W*8); // space for 7 gaps
    let dynamicGap = Math.floor(avail / 7);
    if (isNaN(dynamicGap) || !isFinite(dynamicGap)) dynamicGap = 0;
    if (dynamicGap < 0) dynamicGap = 0; // allow zero-gap when extremely narrow

    TopGeom.fGap = dynamicGap; // will expand automatically on wider screens
    TopGeom.fStep = CARD_W + TopGeom.fGap; TopGeom.fY = PADDING;
    TopGeom.fWidth = CARD_W*8 + TopGeom.fGap*7; // 8 piles, 7 gaps

    const centeredStart = Math.floor((r.width - TopGeom.fWidth)/2);
    // honor both constraints: to the right of stock, and fully within viewport
    TopGeom.fStartX = Math.max(minStart, centeredStart);
    // final clamp to keep entire row inside right padding
    const maxStart = r.width - PADDING - TopGeom.fWidth;
    if (TopGeom.fStartX > maxStart) TopGeom.fStartX = Math.max(minStart, maxStart);
  }

  // --- Game setup ---
  function buildDeck(){
    deck = [];
    for(let d=0; d<2; d++) for(const s of SUITS) for(const r of RANKS) deck.push(new Card(s,r));
    for(let i=deck.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
  }
  function newGame(){
    buildDeck(); tableau=new Array(10).fill(0).map(()=>[]); devilsSix=[]; foundations=new Array(8).fill(0).map(()=>[]); stock=[]; undoStack=[];
    for(let i=0;i<6;i++){ const c=deck.pop(); c.faceUp=true; devilsSix.push(c); }
    const downs=[0,1,2,3,4,4,3,2,1,0];
    for(let col=0; col<10; col++){
      for(let d=0; d<downs[col]; d++){ const c=deck.pop(); c.faceUp=false; tableau[col].push(c);} const up=deck.pop(); up.faceUp=true; tableau[col].push(up);
    }
    stock = deck; deals=0; document.getElementById('deals').textContent = deals;
    timeStart=Date.now(); if(ticker) clearInterval(ticker); ticker=setInterval(()=>{ const s=Math.floor((Date.now()-timeStart)/1000); const m=(s/60|0).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0'); document.getElementById('time').textContent=`${m}:${ss}`; },1000);
    updateUI(); draw();
  }

  // --- Drawing ---
  function drawCard(card,x,y,opts={}){
    const {ghost=false, highlight=false, emptyHint=false, foundationSuit=null} = opts;
    ctx.save(); ctx.translate(x,y);
    if(highlight){ ctx.shadowColor='rgba(230,194,41,.9)'; ctx.shadowBlur=16; }
    ctx.fillStyle='#fff'; ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.globalAlpha=ghost?0.85:1;
    if(card){
      ctx.fillRect(0,0,CARD_W,CARD_H); ctx.strokeRect(0,0,CARD_W,CARD_H);
      if(card.faceUp){
        ctx.fillStyle = (card.color==='red') ? '#c72a2a' : '#111'; ctx.font = `bold ${Math.floor(CARD_W/3)}px system-ui`;
        ctx.textAlign='left'; ctx.textBaseline='top'; ctx.fillText(card.rank,6,4); ctx.fillText(card.suit,6,Math.floor(CARD_H/2));
        ctx.save(); ctx.translate(CARD_W-6,CARD_H-4); ctx.rotate(Math.PI); ctx.fillText(card.rank,0,0); ctx.fillText(card.suit,0,Math.floor(CARD_H/2)); ctx.restore();
      } else { ctx.fillStyle='#1f4aa8'; ctx.fillRect(4,4,CARD_W-8,CARD_H-8); ctx.strokeStyle='#d9e2ff'; ctx.strokeRect(8,8,CARD_W-16,CARD_H-16); }
    } else {
      ctx.setLineDash([6,6]); ctx.strokeStyle='#e6c229'; ctx.strokeRect(0,0,CARD_W,CARD_H); ctx.setLineDash([]);
      if(emptyHint && foundationSuit){ ctx.fillStyle='#888'; ctx.font=`bold ${Math.floor(CARD_W/3)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('A'+foundationSuit, CARD_W/2, CARD_H/2); }
    }
    ctx.restore();
  }

  function draw(){
    layout(); computeTopGeometry();
    const r = canvas.getBoundingClientRect(); ctx.clearRect(0,0,r.width,r.height);

    // Devil's Six (top-left)
    for(let i=0;i<devilsSix.length;i++) drawCard(devilsSix[i], TopGeom.dsX + i*(CARD_W+TopGeom.dsGap), TopGeom.dsY);

    // Stock (right of DS)
    drawCard(stock.length? {faceUp:false}: null, TopGeom.stockX, TopGeom.stockY);
    stockHitRect = {x:TopGeom.stockX, y:TopGeom.stockY, w:CARD_W, h:CARD_H};

    // Foundations (centered top, guaranteed to the right of stock)
    for(let i=0;i<8;i++){
      const stack = foundations[i]; const top = stack[stack.length-1]||null;
      drawCard(top, TopGeom.fStartX + i*TopGeom.fStep, TopGeom.fY, {emptyHint:!top, foundationSuit: SUITS[i%4]});
    }

    // Tableau
    const tY = tableauTopY();
    for(let c=0;c<10;c++){
      const x = colX(c);
      if(tableau[c].length===0) drawCard(null,x,tY);
      else for(let i=0;i<tableau[c].length;i++){
        const card = tableau[c][i];
        if(drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
        drawCard(card, x, tY + i*OVERLAP);
      }
    }

    // Drag visuals
    if(drag){ const cards=drag.cards; for(let i=0;i<cards.length;i++){ drawCard(cards[i], mouseX - CARD_W/2, mouseY - CARD_H/2 + i*OVERLAP, {ghost:true, highlight:true}); } }
  }

  // --- Hit-testing & interactions ---
  let mouseX=0, mouseY=0; let stockHitRect={x:0,y:0,w:0,h:0};
  canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; if(drag) draw(); });

  function cardAt(x,y){
    // Foundations
    computeTopGeometry();
    for(let i=0;i<8;i++){
      const fx = TopGeom.fStartX + i*TopGeom.fStep; const fy = TopGeom.fY;
      if(x>fx && x<fx+CARD_W && y>fy && y<fy+CARD_H) return {type:'foundation', idx:i};
    }
    // Devil's Six
    for(let i=0;i<devilsSix.length;i++){
      const dx=TopGeom.dsX + i*(CARD_W+TopGeom.dsGap), dy=TopGeom.dsY;
      if(x>dx && x<dx+CARD_W && y>dy && y<dy+CARD_H) return {type:'devils', idx:i};
    }
    // Stock
    if(stock.length && x>stockHitRect.x && x<stockHitRect.x+CARD_W && y>stockHitRect.y && y<stockHitRect.y+CARD_H) return {type:'stock'};
    // Tableau
    const tY = tableauTopY();
    for(let c=0;c<10;c++){
      const cx=colX(c); const col=tableau[c];
      if(col.length===0){ if(x>cx&&x<cx+CARD_W&&y>tY&&y<tY+CARD_H) return {type:'tableau', col:c, row:-1}; continue; }
      for(let i=col.length-1;i>=0;i--){ const cy=tY+i*OVERLAP; if(x>cx&&x<cx+CARD_W&&y>cy&&y<cy+CARD_H) return {type:'tableau', col:c, row:i}; }
    }
    return null;
  }

  function getRunLength(col, startIdx){ let len=1; const c=tableau[col]; for(let i=startIdx+1;i<c.length;i++){ const prev=c[i-1], cur=c[i]; if(!cur.faceUp) break; if(prev.color===cur.color) break; if(cur.value!==prev.value-1) break; len++; } return len; }
  function canPlaceOnTableau(card,toCol){ const t=tableau[toCol]; const top=t[t.length-1]; if(!top) return card.value===13; return (card.color!==top.color)&&(card.value===top.value-1); }
  function canPlaceOnFoundation(card,fIdx){ if(SUITS[fIdx%4]!==card.suit) return false; const stack=foundations[fIdx]; const top=stack[stack.length-1]; return top ? (card.value===top.value+1) : (card.value===1); }

  let drag=null; // {from:{type:'tableau'|'devils', col?, idx?}, cards:Card[]}

  canvas.addEventListener('mousedown', e=>{
    const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; const hit=cardAt(mouseX,mouseY); if(!hit) return;
    if(hit.type==='stock'){ doDeal(); return; }

    // Click-to-foundation for ACES ONLY
    if(hit.type==='tableau' && hit.row>=0){
      const topIdx = tableau[hit.col].length-1; const isTop=(hit.row===topIdx); const card=tableau[hit.col][hit.row];
      if(isTop && card.faceUp && card.value===1){
        const suit=card.suit; const candidates=[0,1,2,3,4,5,6,7].filter(i=>SUITS[i%4]===suit);
        let placed=false; for(const f of candidates){ if(foundations[f].length===0){ undoStack.push({kind:'toFound', from:{type:'tableau', col:hit.col, idx:hit.row}, fIdx:f, card}); tableau[hit.col].splice(hit.row,1); flipTop(hit.col); foundations[f].push(card); placed=true; break; } }
        if(!placed){ for(const f of candidates){ if(canPlaceOnFoundation(card,f)){ undoStack.push({kind:'toFound', from:{type:'tableau', col:hit.col, idx:hit.row}, fIdx:f, card}); tableau[hit.col].splice(hit.row,1); flipTop(hit.col); foundations[f].push(card); placed=true; break; } } }
        if(placed){ draw(); updateUI(); checkWinOrStuck(); return; }
      }
    }
    if(hit.type==='devils'){
      const card=devilsSix[hit.idx];
      if(card && card.value===1){ const suit=card.suit; const candidates=[0,1,2,3,4,5,6,7].filter(i=>SUITS[i%4]===suit); let placed=false;
        for(const f of candidates){ if(foundations[f].length===0){ undoStack.push({kind:'toFound', from:{type:'devils', idx:hit.idx}, fIdx:f, card}); devilsSix.splice(hit.idx,1); foundations[f].push(card); placed=true; break; } }
        if(!placed){ for(const f of candidates){ if(canPlaceOnFoundation(card,f)){ undoStack.push({kind:'toFound', from:{type:'devils', idx:hit.idx}, fIdx:f, card}); devilsSix.splice(hit.idx,1); foundations[f].push(card); placed=true; break; } } }
        if(placed){ draw(); updateUI(); checkWinOrStuck(); return; }
      }
    }

    // Start a drag
    if(hit.type==='tableau'){
      const col=hit.col, row=hit.row; if(row<0) return; const card=tableau[col][row]; if(!card||!card.faceUp) return; const len=getRunLength(col,row); drag={from:{type:'tableau', col, idx:row}, cards:tableau[col].slice(row,row+len)}; draw(); return;
    }
    if(hit.type==='devils'){ const card=devilsSix[hit.idx]; if(!card) return; drag={from:{type:'devils', idx:hit.idx}, cards:[card]}; draw(); return; }
  });

  window.addEventListener('mouseup', e=>{
    if(!drag) return; const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; const drop=cardAt(mouseX,mouseY); const moving=drag.cards[0]; let moved=false;
    if(drop){
      if(drop.type==='foundation' && drag.cards.length===1 && canPlaceOnFoundation(moving,drop.idx)){
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        if(drag.from.type==='tableau'){ tableau[drag.from.col].splice(drag.from.idx,1); flipTop(drag.from.col); } else { devilsSix.splice(drag.from.idx,1); }
        foundations[drop.idx].push(moving); moved=true;
      }
      if(!moved && drop.type==='tableau' && drag.from.type==='tableau' && canPlaceOnTableau(moving, drop.col)){
        const fromCol=drag.from.col, fromIdx=drag.from.idx, run=drag.cards.slice();
        undoStack.push({kind:'tab2tab', from:{col:fromCol, idx:fromIdx}, toCol:drop.col, count:run.length});
        tableau[drop.col].push(...run); tableau[fromCol].splice(fromIdx, run.length); flipTop(fromCol); moved=true;
      }
    }
    drag=null; draw(); if(moved){ updateUI(); checkWinOrStuck(); }
  });

  function flipTop(col){ const t=tableau[col]; if(t.length && !t[t.length-1].faceUp) t[t.length-1].faceUp=true; }
  function doDeal(){ if(!stock.length) return; const dealt=[]; for(let c=0;c<10;c++){ const t=tableau[c]; const top=t[t.length-1]; if(!top || top.value!==13){ const card=stock.pop(); card.faceUp=true; t.push(card); dealt.push({col:c,card}); } } if(dealt.length){ deals++; document.getElementById('deals').textContent=deals; undoStack.push({kind:'deal', dealt}); draw(); updateUI(); checkWinOrStuck(); } }

  function hasAnyMoves(){
    if(devilsSix.some(c=>foundations.some((_,i)=>canPlaceOnFoundation(c,i)))) return true;
    for(let c=0;c<10;c++){ const t=tableau[c]; const top=t[t.length-1]; if(top && foundations.some((_,i)=>canPlaceOnFoundation(top,i))) return true; }
    for(let from=0; from<10; from++){ const t=tableau[from]; let start=t.findIndex(c=>c.faceUp); if(start<0) continue; for(let i=start;i<t.length;i++){ const base=t[i]; for(let to=0; to<10; to++){ if(to===from) continue; if(canPlaceOnTableau(base,to)) return true; } } }
    return false;
  }

  function checkWinOrStuck(){
    const totalFound = foundations.reduce((n,s)=>n+s.length,0);
    if(totalFound===104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      const secs=Math.floor((Date.now()-timeStart)/1000); career = career + Math.max(100, 1000 - deals*100 - Math.floor(secs/10)); localStorage.setItem('careerScore', career); document.getElementById('careerScore').textContent = career;
      showMessage('Victory! All eight foundations completed.'); return;
    }
    if(!stock.length && !hasAnyMoves()) showMessage('Stuck. No more moves and stock is empty.');
  }

  function showMessage(t){ document.getElementById('messageText').textContent=t; document.getElementById('message').style.display='block'; updateUI(true); if(ticker) clearInterval(ticker); }
  function hideMessage(){ document.getElementById('message').style.display='none'; }
  function updateUI(end=false){ document.getElementById('deal').disabled = stock.length===0; document.getElementById('undo').disabled = undoStack.length===0; if(end){ document.getElementById('deal').disabled=true; document.getElementById('hint').disabled=true; document.getElementById('undo').disabled=true; } }

  function hint(){
    for(let c=0;c<10;c++){ const t=tableau[c]; const top=t[t.length-1]; if(top){ for(let f=0;f<8;f++){ if(canPlaceOnFoundation(top,f)){ flashCell(()=>{ const x=colX(c), y=tableauTopY()+ (t.length-1)*OVERLAP; drawCard(top,x,y,{highlight:true}); }); return; } } } }
    for(let i=0;i<devilsSix.length;i++){ const card=devilsSix[i]; for(let f=0;f<8;f++){ if(canPlaceOnFoundation(card,f)){ const x=TopGeom.dsX+i*(CARD_W+TopGeom.dsGap), y=TopGeom.dsY; flashCell(()=>drawCard(card,x,y,{highlight:true})); return; } } }
    for(let from=0;from<10;from++){ const t=tableau[from]; for(let i=0;i<t.length;i++){ if(!t[i].faceUp) continue; const base=t[i]; for(let to=0;to<10;to++){ if(to===from) continue; if(canPlaceOnTableau(base,to)){ const x=colX(from), y=tableauTopY()+ i*OVERLAP; flashCell(()=>drawCard(base,x,y,{highlight:true})); return; } } } }
  }
  function flashCell(paint){ let n=0; const id=setInterval(()=>{ draw(); if(n%2===0) paint(); if(++n>5) clearInterval(id); },120); }

  // Undo
  document.getElementById('undo').addEventListener('click', ()=>{ if(!undoStack.length) return; const step=undoStack.pop(); if(step.kind==='deal'){ for(let i=step.dealt.length-1;i>=0;i--){ const {col,card}=step.dealt[i]; tableau[col].pop(); card.faceUp=false; stock.push(card); } deals=Math.max(0,deals-1); document.getElementById('deals').textContent=deals; } if(step.kind==='tab2tab'){ const moved=tableau[step.toCol].splice(-step.count, step.count); tableau[step.from.col].splice(step.from.idx,0,...moved); flipTop(step.from.col); } if(step.kind==='toFound'){ const card=foundations[step.fIdx].pop(); if(step.from.type==='tableau'){ tableau[step.from.col].splice(step.from.idx,0,card); } else { devilsSix.splice(step.from.idx,0,card); } } draw(); updateUI(); });

  document.getElementById('newGame').addEventListener('click', ()=>{ hideMessage(); newGame(); });
  document.getElementById('deal').addEventListener('click', doDeal);
  document.getElementById('hint').addEventListener('click', hint);
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideMessage(); newGame(); });

  // --- Minimal Test Suite (non-intrusive) ---
  function tAssert(cond, msg){ if(!tAssert.results) tAssert.results=[]; tAssert.results.push({ok:!!cond, msg}); if(!cond) console.error('TEST FAIL:', msg); }
  function runTests(){
    tAssert(Array.isArray(foundations) && foundations.length===8, '8 foundations exist');
    tAssert(devilsSix.length===6, 'Devil\'s Six has 6 cards');
    const downs=[0,1,2,3,4,4,3,2,1,0];
    for(let c=0;c<10;c++){ tAssert(tableau[c].length===downs[c]+1, `Tableau col ${c} has correct initial length`); }
    // canPlaceOnTableau
    const red7={suit:'♥', rank:'7', faceUp:true, color:'red', value:7};
    const black8={suit:'♠', rank:'8', faceUp:true, color:'black', value:8};
    tableau[0]=[black8]; tableau[1]=[red7]; tAssert(canPlaceOnTableau(red7,0),'7 red onto 8 black is legal');
    const red8={suit:'♥', rank:'8', faceUp:true, color:'red', value:8}; tableau[0]=[red8]; tAssert(!canPlaceOnTableau(red7,0),'7 red onto 8 red is illegal');
    // canPlaceOnFoundation build order
    foundations = new Array(8).fill(0).map(()=>[]);
    const aSpade={suit:'♠', rank:'A', faceUp:true, color:'black', value:1};
    const twoSpade={suit:'♠', rank:'2', faceUp:true, color:'black', value:2};
    tAssert(canPlaceOnFoundation(aSpade,0),'Ace starts spade foundation');
    foundations[0].push(aSpade); tAssert(canPlaceOnFoundation(twoSpade,0),'2 goes on A♠');
    // geometry invariants
    computeTopGeometry();
    tAssert(TopGeom.fStartX >= TopGeom.stockX + CARD_W + 20, 'Foundations start to the right of stock');
    const r = canvas.getBoundingClientRect();
    tAssert(TopGeom.fStartX + TopGeom.fWidth <= r.width - PADDING + 1, 'Foundations fit in viewport');
    // reset tableau for drawing
    newGame();
    // Print results
    const out=document.getElementById('testout'); const fails=tAssert.results.filter(r=>!r.ok).length; out.textContent = fails?`Tests: ${tAssert.results.length-fails} passed, ${fails} failed`:`Tests: ${tAssert.results.length} passed`; }

  // boot
  resizeCanvas(); layout(); newGame(); runTests();
  </script>
</body>
</html>
