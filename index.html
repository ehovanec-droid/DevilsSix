<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Churchill Solitaire — Devil's Six</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(ellipse at center, #0e6a30 0%, #06421d 70%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #fff;
      overflow: hidden;
      user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; }

    /* Control panel – we will place it to the RIGHT of Devil's Six when space allows, otherwise just below */
    #ui {
      position:absolute;
      top:70px;
      left:16px;
      z-index:2;
      display:flex;
      gap:10px 12px;
      align-items:center;
      background:rgba(0,0,0,.30);
      padding:6px 8px;
      border-radius:8px;
      backdrop-filter: blur(2px);
    }
    .btn {
      background:rgba(0,0,0,.6);
      color:#fff;
      border:2px solid #e6c229;
      padding:8px 14px;
      border-radius:10px;
      font-weight:700;
      cursor:pointer;
      font-size:14px;
      transition:background .15s ease;
    }
    .btn:hover:not(:disabled) { background:rgba(230,194,41,.3); }
    .btn:disabled { opacity:.55; cursor:not-allowed; }

    #status {
      position:absolute;
      top:12px;
      right:12px;
      text-align:right;
      font-weight:700;
      text-shadow:0 2px 6px rgba(0,0,0,.6);
    }
    #message {
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.85);
      padding:28px 32px;
      border:3px solid #e6c229;
      border-radius:12px;
      display:none;
      z-index:3;
    }
    #testout {
      position:absolute;
      bottom:8px;
      left:8px;
      background:rgba(0,0,0,.6);
      padding:6px 8px;
      border-radius:6px;
      font-size:11px;
      max-width:60ch;
      line-height:1.3;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="newGame" class="btn">New Game</button>
    <button id="deal" class="btn">Deal</button>
    <button id="hint" class="btn">Hint</button>
    <button id="undo" class="btn">Undo</button>
  </div>
  <div id="status">
    <div>Time: <span id="time">00:00</span></div>
    <div>Deals: <span id="deals">0</span></div>
    <div>Career: <span id="careerScore">0</span></div>
  </div>
  <div id="message">
    <div id="messageText" style="margin-bottom:14px;font-size:20px"></div>
    <div style="text-align:center"><button id="playAgain" class="btn">Play Again</button></div>
  </div>
  <div id="testout"></div>
  <canvas id="game"></canvas>
  <script>
  // ===== CORE CONSTANTS =====
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const SUITS = ['\u2660','\u2665','\u2666','\u2663']; // ♠ ♥ ♦ ♣
  const COLORS = { '\u2660':'black', '\u2663':'black', '\u2665':'red', '\u2666':'red' };
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL  = { A:1, J:11, Q:12, K:13 };
  for (let i=2;i<=10;i++) RVAL[i]=i;
  const PADDING = 16;

  // ===== CARD CLASS =====
  class Card {
    constructor(suit, rank){
      this.suit = suit;
      this.rank = rank;
      this.value = RVAL[rank];
      this.color = COLORS[suit];
      this.faceUp = false;
    }
  }

  // ===== STATE =====
  let tableau = new Array(10).fill(0).map(()=>[]);
  let devilsSix = [];
  let foundations = new Array(8).fill(0).map(()=>[]);
  let stock = [];
  let deck = [];
  let deals = 0;
  let timeStart = 0; let timer = null;
  let undoStack = [];
  let career = +localStorage.getItem('careerScore') || 0;
  document.getElementById('careerScore').textContent = career;

  // card drawing sizes (responsive)
  let CARD_W = 80, CARD_H = 120, OVERLAP = 26;

  // top band geometry
  const TopGeom = {
    dsX: PADDING,
    dsY: PADDING,
    dsStep: 50,
    stockX: 0,
    stockY: 0,
    fSlots: [],
    fCols: 4,
    fRows: 2,
    fGapX: 10,
    fGapY: 8,
    fY: PADDING
  };

  // ===== RESIZE / LAYOUT =====
  function layout(){
    const w = canvas.getBoundingClientRect().width;
    CARD_W = Math.max(58, Math.min(90, Math.floor((w - PADDING*2)/14)));
    CARD_H = Math.floor(CARD_W * 1.5);
    OVERLAP = Math.floor(CARD_H * 0.30);
  }
  function tableauGutter(){
    const w = canvas.getBoundingClientRect().width;
    const available = w - PADDING*2 - CARD_W*10;
    return Math.max(4, Math.floor(available/9));
  }
  function colX(c){ return PADDING + c * (CARD_W + tableauGutter()); }
  function tableauTopY(){
    const top = TopGeom.fY + (CARD_H * TopGeom.fRows) + (TopGeom.fGapY * (TopGeom.fRows - 1)) + 24;
    return Math.max(top, CARD_H + 48);
  }
  function computeTopGeometry(){
    const r = canvas.getBoundingClientRect();
    TopGeom.dsX = PADDING;
    TopGeom.dsY = PADDING;
    TopGeom.dsStep = Math.max(Math.floor(CARD_W * 0.62), 34); // tighter, like commercial app
    const dsVisualWidth = CARD_W + (6-1)*TopGeom.dsStep;
    TopGeom.stockX = TopGeom.dsX + dsVisualWidth + 14;
    TopGeom.stockY = TopGeom.dsY;

    // 2 rows of 4 foundations, right-aligned
    TopGeom.fCols = 4; TopGeom.fRows = 2;
    TopGeom.fGapX = 10; TopGeom.fGapY = 8; TopGeom.fY = PADDING;
    const totalFW = TopGeom.fCols*CARD_W + (TopGeom.fCols-1)*TopGeom.fGapX;
    const startX = Math.max(TopGeom.stockX + CARD_W + 18, r.width - PADDING - totalFW);
    TopGeom.fSlots = [];
    for (let row=0; row<TopGeom.fRows; row++){
      for (let col=0; col<TopGeom.fCols; col++){
        const x = startX + col*(CARD_W + TopGeom.fGapX);
        const y = TopGeom.fY + row*(CARD_H + TopGeom.fGapY);
        TopGeom.fSlots.push({x,y});
      }
    }
  }
  function placeButtons(){
    const ui = document.getElementById('ui');
    const r = canvas.getBoundingClientRect();
    const dsRight = TopGeom.dsX + CARD_W + (6-1)*TopGeom.dsStep;
    const uiWidth = ui.getBoundingClientRect().width;
    // try to put to the right of DS if it fits, otherwise below
    if (dsRight + 14 + uiWidth < r.width - 260) {
      ui.style.left = (dsRight + 14) + 'px';
      ui.style.top = (TopGeom.dsY + 2) + 'px';
    } else {
      ui.style.left = TopGeom.dsX + 'px';
      ui.style.top  = (TopGeom.dsY + CARD_H + 10) + 'px';
    }
  }
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    layout();
    computeTopGeometry();
    placeButtons();
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // ===== CARDS / DRAW =====
  function drawCard(card,x,y,opts={}){
    const {ghost=false,highlight=false,empty=false,suitHint=null} = opts;
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = ghost ? 0.82 : 1;
    if (card){
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 2;
      ctx.fillRect(0,0,CARD_W,CARD_H);
      ctx.strokeRect(0,0,CARD_W,CARD_H);
      if (card.faceUp){
        ctx.fillStyle = card.color==='red' ? '#c52929' : '#111';
        ctx.font = `bold ${Math.floor(CARD_W/3)}px system-ui`;
        ctx.textAlign='left'; ctx.textBaseline='top';
        ctx.fillText(card.rank,6,4);
        ctx.fillText(card.suit,6,Math.floor(CARD_H/2));
        ctx.save(); ctx.translate(CARD_W-6,CARD_H-4); ctx.rotate(Math.PI);
        ctx.fillText(card.rank,0,0); ctx.fillText(card.suit,0,Math.floor(CARD_H/2)); ctx.restore();
      } else {
        ctx.fillStyle = '#1947a5';
        ctx.fillRect(4,4,CARD_W-8,CARD_H-8);
        ctx.strokeStyle = '#cfd9ff';
        ctx.strokeRect(8,8,CARD_W-16,CARD_H-16);
      }
      if (highlight){
        ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 3;
        ctx.strokeRect(1,1,CARD_W-2,CARD_H-2);
      }
    } else {
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = '#e6c229';
      ctx.strokeRect(0,0,CARD_W,CARD_H);
      ctx.setLineDash([]);
      if (suitHint){
        ctx.fillStyle='#888';
        ctx.font=`bold ${Math.floor(CARD_W/3)}px system-ui`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('A'+suitHint, CARD_W/2, CARD_H/2);
      }
    }
    ctx.restore();
  }

  let stockHit = {x:0,y:0,w:0,h:0};
  let drag = null; // {from:{...}, cards:[]}
  let mouseX = 0, mouseY = 0;

  function draw(){
    const r = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);
    // Devil's Six
    for (let i=0;i<devilsSix.length;i++){
      drawCard(devilsSix[i], TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY);
    }
    // Stock
    drawCard(stock.length ? {faceUp:false} : null, TopGeom.stockX, TopGeom.stockY);
    stockHit = {x:TopGeom.stockX, y:TopGeom.stockY, w:CARD_W, h:CARD_H};
    // Foundations (2 x 4)
    for (let i=0;i<8;i++){
      const slot = TopGeom.fSlots[i];
      const stack = foundations[i];
      const top = stack.length ? stack[stack.length-1] : null;
      drawCard(top, slot.x, slot.y, {empty:!top, suitHint:SUITS[i%4]});
    }
    // Tableau
    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const x = colX(c);
      const col = tableau[c];
      if (col.length===0){ drawCard(null,x,tY); continue; }
      for (let i=0;i<col.length;i++){
        const card = col[i];
        if (drag && drag.from.type==='tableau' && drag.from.col===c && i>=drag.from.idx) continue;
        drawCard(card, x, tY + i*OVERLAP);
      }
    }
    // Drag stack on top
    if (drag){
      for (let i=0;i<drag.cards.length;i++){
        drawCard(drag.cards[i], mouseX - CARD_W/2, mouseY - CARD_H/2 + i*OVERLAP, {ghost:true,highlight:true});
      }
    }
  }

  // ===== HITTEST =====
  function hitAt(x,y){
    // foundations first
    for (let i=0;i<8;i++){
      const s = TopGeom.fSlots[i];
      if (x>s.x && x<s.x+CARD_W && y>s.y && y<s.y+CARD_H) return {type:'foundation', idx:i};
    }
    // devils six
    for (let i=0;i<devilsSix.length;i++){
      const dx = TopGeom.dsX + i*TopGeom.dsStep, dy=TopGeom.dsY;
      if (x>dx && x<dx+CARD_W && y>dy && y<dy+CARD_H) return {type:'devils', idx:i};
    }
    // stock
    if (stock.length && x>stockHit.x && x<stockHit.x+CARD_W && y>stockHit.y && y<stockHit.y+CARD_H){
      return {type:'stock'};
    }
    // tableau
    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const cx = colX(c); const col = tableau[c];
      if (col.length===0){ if (x>cx && x<cx+CARD_W && y>tY && y<tY+CARD_H) return {type:'tableau', col:c, row:-1}; continue; }
      for (let i=col.length-1;i>=0;i--){
        const cy = tY + i*OVERLAP;
        if (x>cx && x<cx+CARD_W && y>cy && y<cy+CARD_H) return {type:'tableau', col:c, row:i};
      }
    }
    return null;
  }

  // ===== RULES =====
  function getRunLength(col, start){
    const arr = tableau[col];
    let len = 1;
    for (let i=start+1;i<arr.length;i++){
      const prev = arr[i-1], cur = arr[i];
      if (!cur.faceUp) break;
      if (prev.color === cur.color) break;
      if (cur.value !== prev.value - 1) break;
      len++;
    }
    return len;
  }
  function canPlaceOnTableau(card, toCol){
    const col = tableau[toCol];
    const top = col[col.length-1];
    if (!top) return card.value === 13; // only K on empty
    return (card.color !== top.color) && (card.value === top.value - 1);
  }
  function canPlaceOnFoundation(card, fIdx){
    // STRICT: correct suit + next rank only
    if (SUITS[fIdx % 4] !== card.suit) return false;
    const stack = foundations[fIdx];
    const top   = stack[stack.length-1];
    return top ? (card.value === top.value + 1) : (card.value === 1);
  }
  function flipTop(col){
    const colArr = tableau[col];
    if (colArr.length && !colArr[colArr.length-1].faceUp) colArr[colArr.length-1].faceUp = true;
  }
  function canStartDragAt(col, row){
    const colArr = tableau[col];
    if (row < 0 || row >= colArr.length) return false;
    const card = colArr[row];
    if (!card.faceUp) return false;
    // if there is a face-up card above, it must chain correctly — otherwise blocked
    if (row>0 && colArr[row-1].faceUp){
      const above = colArr[row-1];
      if (!(above.color !== card.color && above.value === card.value + 1)) return false;
    }
    return true;
  }

  // ===== DEAL =====
  function doDeal(){
    if (!stock.length) return;
    // check if all 10 piles are king-anchored (face-up K on top)
    let allAnchored = true;
    for (let c = 0; c < 10; c++) {
      const col = tableau[c];
      const top = col[col.length - 1];
      if (!(top && top.faceUp && top.value === 13)) { // not an anchored king
        allAnchored = false;
        break;
      }
    }
    if (allAnchored) return;

    const dealt = [];
    for (let c = 0; c < 10; c++) {
      if (!stock.length) break; // ran out mid-pass
      const col = tableau[c];
      const top = col[col.length - 1];
      const anchoredByKing = !!top && top.faceUp && top.value === 13;
      if (anchoredByKing) continue;
      const card = stock.pop();
      if (!card) break;
      card.faceUp = true;
      col.push(card);
      dealt.push({ col: c, card });
    }
    if (!dealt.length) {
      draw();
      updateUI();
      return;
    }
    deals++;
    document.getElementById('deals').textContent = deals;
    undoStack.push({ kind: 'deal', payload: dealt });
    draw();
    updateUI();
    checkWinOrStuck();
  }

  // ===== GAME STATE CHECKS =====
  function hasAnyMoves(){
    // to foundation from tableau
    for (let c=0;c<10;c++){
      const top = tableau[c][tableau[c].length-1];
      if (!top) continue;
      for (let f=0;f<8;f++) if (canPlaceOnFoundation(top,f)) return true;
    }
    // from Devil's Six
    for (const card of devilsSix){ for (let f=0;f<8;f++) if (canPlaceOnFoundation(card,f)) return true; }
    // tableau-to-tableau
    for (let from=0;from<10;from++){
      const col = tableau[from];
      const start = col.findIndex(c=>c.faceUp);
      if (start<0) continue;
      for (let i=start;i<col.length;i++){
        const base = col[i];
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(base,to)) return true;
        }
      }
    }
    return false;
  }
  function checkWinOrStuck(){
    const total = foundations.reduce((n,s)=>n+s.length,0);
    if (total === 104 && foundations.every(s=>s.length===13 && s[s.length-1].value===13)){
      finishGame(true);
      return;
    }
    if (!stock.length && !hasAnyMoves()){
      finishGame(false);
    }
  }
  function finishGame(win){
    if (win){
      const secs = Math.floor((Date.now()-timeStart)/1000);
      const score = Math.max(50, 1000 - deals*100 - Math.floor(secs/10));
      career += score;
      localStorage.setItem('careerScore', career);
      document.getElementById('careerScore').textContent = career;
      showMessage('Victory! Foundations complete.');
    } else {
      showMessage('No more moves.');
    }
  }

  // ===== NEW GAME =====
  function buildDeck(){
    const temp = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          temp.push(new Card(s,r));
        }
      }
    }
    // Fisher-Yates
    for (let i=temp.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [temp[i], temp[j]] = [temp[j], temp[i]];
    }
    deck = temp; // 104 unique cards
  }
  function newGame(){
    buildDeck();
    tableau = new Array(10).fill(0).map(()=>[]);
    devilsSix = [];
    foundations = new Array(8).fill(0).map(()=>[]);
    stock = [];
    undoStack = [];

    // Devil's Six (always 6 face-up)
    for (let i=0;i<6;i++){ const c=deck.pop(); c.faceUp=true; devilsSix.push(c); }

    // tableau initial
    const downs = [0,1,2,3,4,4,3,2,1,0];
    for (let col=0; col<10; col++){
      for (let d=0; d<downs[col]; d++){
        const c = deck.pop(); c.faceUp=false; tableau[col].push(c);
      }
      const up = deck.pop(); up.faceUp=true; tableau[col].push(up);
    }
    // remaining is stock
    stock = deck;
    deals = 0; document.getElementById('deals').textContent = deals;
    timeStart = Date.now();
    if (timer) clearInterval(timer);
    timer = setInterval(()=>{
      const s = Math.floor((Date.now()-timeStart)/1000);
      const m = (s/60|0).toString().padStart(2,'0');
      const ss = (s%60).toString().padStart(2,'0');
      document.getElementById('time').textContent = `${m}:${ss}`;
    },1000);
    updateUI();
    draw();
  }

  // ===== UI HELPERS =====
  function updateUI(disable=false){
    document.getElementById('deal').disabled = disable || stock.length===0;
    document.getElementById('undo').disabled = disable || undoStack.length===0;
    document.getElementById('hint').disabled = disable;
  }
  function showMessage(t){
    document.getElementById('messageText').textContent = t;
    document.getElementById('message').style.display = 'block';
    updateUI(true);
    if (timer) clearInterval(timer);
  }
  function hideMessage(){ document.getElementById('message').style.display = 'none'; }

  // ===== EVENTS =====
  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left; mouseY = e.clientY - r.top;
    if (drag) draw();
  });
  canvas.addEventListener('mousedown', e=>{
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left; mouseY = e.clientY - r.top;
    const hit = hitAt(mouseX, mouseY);
    if (!hit) return;
    if (hit.type==='stock'){ doDeal(); return; }

    // click-to-foundation ONLY for aces
    if (hit.type==='tableau' && hit.row>=0){
      const card = tableau[hit.col][hit.row];
      if (card.faceUp && card.value===1 && canStartDragAt(hit.col, hit.row)){
        const candidates = [];
        for (let f=0;f<8;f++){ if (SUITS[f%4]===card.suit) candidates.push(f); }
        let placed = false;
        // first try empty of that suit
        for (const f of candidates){ if (foundations[f].length===0){ foundations[f].push(card); tableau[hit.col].splice(hit.row,1); flipTop(hit.col); undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card}); placed=true; break; } }
        // then try correct next-rank
        if (!placed){ for (const f of candidates){ if (canPlaceOnFoundation(card,f)){ foundations[f].push(card); tableau[hit.col].splice(hit.row,1); flipTop(hit.col); undoStack.push({kind:'toFound', from:{type:'tableau',col:hit.col,idx:hit.row}, fIdx:f, card}); placed=true; break; } } }
        if (placed){ draw(); updateUI(); checkWinOrStuck(); }
        return;
      }
    }
    if (hit.type==='devils'){
      const card = devilsSix[hit.idx];
      if (card && card.value===1){
        const options = [];
        for (let f=0;f<8;f++){ if (SUITS[f%4]===card.suit) options.push(f); }
        let placed = false;
        for (const f of options){ if (foundations[f].length===0){ foundations[f].push(card); devilsSix.splice(hit.idx,1); undoStack.push({kind:'toFound', from:{type:'devils', idx:hit.idx}, fIdx:f, card}); placed=true; break; } }
        if (!placed){ for (const f of options){ if (canPlaceOnFoundation(card,f)){ foundations[f].push(card); devilsSix.splice(hit.idx,1); undoStack.push({kind:'toFound', from:{type:'devils', idx:hit.idx}, fIdx:f, card}); placed=true; break; } } }
        if (placed){ draw(); updateUI(); checkWinOrStuck(); }
        return;
      }
    }

    // start drag from tableau
    if (hit.type==='tableau'){
      if (hit.row<0) return;
      if (!canStartDragAt(hit.col, hit.row)) return;
      const runLen = getRunLength(hit.col, hit.row);
      drag = {
        from:{type:'tableau', col:hit.col, idx:hit.row},
        cards: tableau[hit.col].slice(hit.row, hit.row + runLen)
      };
      draw();
      return;
    }
    // start drag from devils
    if (hit.type==='devils'){
      const card = devilsSix[hit.idx];
      drag = {from:{type:'devils', idx:hit.idx}, cards:[card]};
      draw();
      return;
    }
  });
  window.addEventListener('mouseup', e=>{
    if (!drag) return;
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left; mouseY = e.clientY - r.top;
    const drop = hitAt(mouseX, mouseY);
    const moving = drag.cards[0];
    let moved = false;
    if (drop){
      // to foundation (single card only, strict)
      if (drop.type==='foundation' && drag.cards.length===1 && canPlaceOnFoundation(moving, drop.idx)){
        foundations[drop.idx].push(moving);
        if (drag.from.type==='tableau'){
          tableau[drag.from.col].splice(drag.from.idx,1); flipTop(drag.from.col);
        } else { devilsSix.splice(drag.from.idx,1); }
        undoStack.push({kind:'toFound', from:JSON.parse(JSON.stringify(drag.from)), fIdx:drop.idx, card:moving});
        moved = true;
      }
      // tableau-to-tableau
      else if (drop.type==='tableau' && drag.from.type==='tableau' && canPlaceOnTableau(moving, drop.col)){
        const run = drag.cards.slice();
        tableau[drop.col].push(...run);
        tableau[drag.from.col].splice(drag.from.idx, run.length);
        flipTop(drag.from.col);
        undoStack.push({kind:'tab2tab', from:{col:drag.from.col, idx:drag.from.idx}, toCol:drop.col, count:run.length});
        moved = true;
      }
    }
    drag = null; draw();
    if (moved){ updateUI(); checkWinOrStuck(); }
  });

  // ===== HINT =====
  function hint(){
    // 1) tableau -> foundation
    const tY = tableauTopY();
    for (let c=0;c<10;c++){
      const col = tableau[c]; const top = col[col.length-1];
      if (!top) continue;
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(top,f)){
          flash(()=>{ drawCard(top, colX(c), tY + (col.length-1)*OVERLAP, {highlight:true}); });
          return;
        }
      }
    }
    // 2) devil -> foundation
    for (let i=0;i<devilsSix.length;i++){
      const card = devilsSix[i];
      for (let f=0;f<8;f++){
        if (canPlaceOnFoundation(card,f)){
          flash(()=>{ drawCard(card, TopGeom.dsX + i*TopGeom.dsStep, TopGeom.dsY, {highlight:true}); });
          return;
        }
      }
    }
    // 3) tableau -> tableau
    for (let from=0;from<10;from++){
      const col = tableau[from];
      for (let i=0;i<col.length;i++){
        if (!col[i].faceUp) continue;
        const card = col[i];
        for (let to=0;to<10;to++){
          if (to===from) continue;
          if (canPlaceOnTableau(card,to)){
            flash(()=>{ drawCard(card, colX(from), tY + i*OVERLAP, {highlight:true}); });
            return;
          }
        }
      }
    }
  }
  function flash(paint){
    let n=0; const id=setInterval(()=>{ draw(); if (n%2===0) paint(); if (++n>5) clearInterval(id); },120);
  }

  // ===== UNDO =====
  document.getElementById('undo').addEventListener('click', ()=>{
    if (!undoStack.length) return;
    const step = undoStack.pop();
    if (step.kind==='deal'){
      for (let i=step.payload.length-1;i>=0;i--){
        const {col,card} = step.payload[i];
        tableau[col].pop();
        card.faceUp = false; // return to stock facedown
        stock.push(card);
      }
      deals = Math.max(0, deals-1);
      document.getElementById('deals').textContent = deals;
    } else if (step.kind==='tab2tab'){
      const moved = tableau[step.toCol].splice(-step.count, step.count);
      tableau[step.from.col].splice(step.from.idx, 0, ...moved);
      flipTop(step.from.col);
    } else if (step.kind==='toFound'){
      const card = foundations[step.fIdx].pop();
      if (step.from.type==='tableau') tableau[step.from.col].splice(step.from.idx,0,card); else devilsSix.splice(step.from.idx,0,card);
    }
    draw(); updateUI();
  });

  // ===== BUTTONS =====
  document.getElementById('newGame').addEventListener('click', ()=>{ hideMessage(); newGame(); });
  document.getElementById('deal').addEventListener('click', doDeal);
  document.getElementById('hint').addEventListener('click', hint);
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideMessage(); newGame(); });

  // ===== TESTS (non-destructive) =====
  function runTests(){
    // Lightweight, non-destructive smoke tests only.
    // The previous version tried to JSON-serialize live Card objects, which
    // stripped methods/fields and broke the running game on load. So now we
    // only assert conditions that do NOT mutate state.
    const out = [];
    // 1. we have 8 foundation slots
    out.push(['8 foundations', Array.isArray(foundations) && foundations.length === 8]);
    // 2. we have 10 tableau columns
    out.push(['10 tableau columns', Array.isArray(tableau) && tableau.length === 10]);
    // 3. devils six is 6 cards, all faceUp
    out.push(['Devils Six has 6 cards', Array.isArray(devilsSix) && devilsSix.length === 6]);
    out.push(['All Devils Six faceUp', devilsSix.every(c => c && c.faceUp));
    // report
    const failed = out.filter(t => !t[1]);
    const el = document.getElementById('testout');
    if (el) {
      el.textContent = failed.length ? `Tests: ${out.length - failed.length}/${out.length} passed, ${failed.length} failed` : `Tests: ${out.length} passed`;
    }
  });

    // 1. 8 foundations exist
    out.push(['8 foundations', Array.isArray(foundations) && foundations.length === 8]);

    // 2. deal skips king column
    tableau[0].push(new Card('♠','K')); tableau[0][tableau[0].length-1].faceUp = true;
    const len0 = tableau[0].length;
    const len1 = tableau[1].length;
    const stockBefore = stock.length;
    // IMPORTANT: use a *test* deal that does NOT push to undoStack or touch DOM
    const testDeal = () => {
      if (!stock.length) return [];
      const placed = [];
      for (let c=0;c<10;c++){
        if (!stock.length) break;
        const col = tableau[c];
        const top = col[col.length-1];
        const anchored = !!top && top.faceUp && top.value === 13;
        if (anchored) continue;
        const card = stock.pop(); card.faceUp = true; col.push(card); placed.push({col,card});
      }
      return placed;
    };
    testDeal();
    out.push(['deal skips king column', tableau[0].length === len0]);
    if (stockBefore>0) out.push(['deal hits non-king', tableau[1].length >= len1]);

    // 3. blocked interior cannot drag
    tableau[3] = [new Card('♠','Q'), new Card('♥','9')];
    tableau[3][0].faceUp = true; tableau[3][1].faceUp = true;
    out.push(['blocked interior cannot drag', !canStartDragAt(3,1)]);

    // 4. foundation strict suit check
    const wrong = new Card('♠','3');
    out.push(['cannot place wrong suit on heart pile', !canPlaceOnFoundation(wrong,1)]);

    // RESTORE to real game state (also restore undo/deals!)
    const rest = JSON.parse(snapshot);
    tableau = rest.tableau;
    devilsSix = rest.devilsSix;
    foundations = rest.foundations;
    stock = rest.stock;
    deck = rest.deck;
    deals = rest.deals;
    undoStack = rest.undoStack || [];
    document.getElementById('deals').textContent = deals;
    draw();

    const failed = out.filter(x=>!x[1]);
    document.getElementById('testout').textContent = failed.length ? `Tests: ${out.length - failed.length}/${out.length} passed, ${failed.length} failed` : `Tests: ${out.length} passed`;
  }

    const failed = out.filter(x=>!x[1]);
    document.getElementById('testout').textContent = failed.length ? `Tests: ${out.length - failed.length}/${out.length} passed, ${failed.length} failed` : `Tests: ${out.length} passed`;
  }

  // ===== BOOT =====
  resizeCanvas();
  newGame();
  runTests();
  </script>
</body>
</html>
